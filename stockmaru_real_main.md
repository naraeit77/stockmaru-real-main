# **I. 강의 소개**

# **나만의 AI 주식 자동매매 시스템 만들기**

안녕하세요\! 본 강의에서는 **나스닥 상위 25개 종목**을 중심으로, **AI 예측 정보**, **기술적 지표** 및 **뉴스 감성 분석**을 결합하여 **자동 매매 로직**을 구현하는 전 과정을 다룹니다.

한국투자증권 API와 연결하여 모의 투자 부터 실제 투자까지 실행하는 방법까지 상세히 배울 수 있습니다.

---

### **1\. 강의 대상**

* **주식 및 경제**에 관심 있는 분  
* **AI 및 금융 투자**에 관심 있는 개발자, 트레이더  
* **나만의 자동매매 시스템**을 직접 구축하고 싶은 분  
* **데이터 사이언스**(데이터 수집, 전처리, 모델링, 시각화)에 관심 있는 분  
* **API 연동**으로 실제 주식 자동 매매를 해보고 싶은 분

---

### **2\. 강의에서 다루는 내용**

### **2.1. 데이터 준비 & DB 설계**

* **나스닥 탑 25개 종목** 선정 이유 및 특징  
* **AI 주가 예측 정보** 준비: Accuracy, Rise Probability 등  
* **DB 테이블 설계**:  
  * **`economic_and_stock_data`** (거시경제 & 주식 지표 저장)  
  * **`access_tokens`** (한국투자증권 API 토큰 관리)  
  * **`predicted_stocks`** (예측 주가 & 실제 주가 저장)  
  * **`ticker_sentiment_analysis`** (뉴스 감성 분석 결과)  
  * **`stock_recommendations`** (기술적 분석 결과 & 추천 정보)

### **2.2. 매매 로직 구성**

1. **매수 로직**  
   * AI 예측 정보 필터링 (Rise Probability ≥ 3%, Accuracy ≥ 80%)  
   * 기술적 지표 (골든 크로스, RSI \< 50, MACD \> Signal)  
   * 뉴스 감성 분석 (평균 감정 점수 ≥ 0.15)  
   * 한국투자증권 API를 통한 **매수 주문**  
2. **매도 로직**  
   * **익절/손절** (+5%/-5%) 예약 주문  
   * 뉴스 감성 분석 (평균 감정 점수 \< \-0.15 → 부정)  
   * 기술적 지표 (데드 크로스, RSI \> 70, MACD \< Signal)  
   * 한국투자증권 API를 통한 **매도 주문** 실행  
3. **최종 로직 흐름**  
   * 매수 대상 선정 → 매수 실행  
   * 보유 종목 관리(익절/손절 기준) → 매도 실행

---

### **3\. 주요 학습 포인트**

1. **실제 데이터 활용**  
   * Fred, Yahoo Finance, Alpha Vantage 등 **외부 API** 데이터 수집  
   * **DB에 저장**하고 관리하는 방법  
2. **기술적 지표 계산 방법**  
   * RSI, 이동평균선(SMA), MACD 등 핵심 지표 계산  
   * **실무 코드** 예시로 이해도 극대화  
3. **뉴스 감성 분석**  
   * Alpha Vantage News API 활용  
   * 단순 점수화(-1 \~ \+1) 후 매매 결정에 반영  
4. **한국투자증권 API 연동**  
   * 해외주식 계좌 연결  
   * **매수/매도 주문** 자동화 코드 구현  
5. **운영 전략**  
   * API 호출 제한 관리, 재시도 로직  
   * **모의투자**를 통한 위험 관리 및 튜닝

---

### **4\. 수강 후 기대 효과**

* **자동매매 시스템**을 직접 구축하고 운영할 수 있는 스킬 확보  
* **주식 예측 모델**(AI) 및 **기술적 지표**의 원리와 적용법 이해  
* **실시간 뉴스 감성 분석**을 통한 매매 의사결정 완성  
* **DB 설계**부터 **API 연동**까지 전 과정을 학습하여, 투자 알고리즘을 \*\*엔드투엔드(End-to-End)\*\*로 구현

---

### **5\. 준비 사항**

* 프로그래밍 언어: **Python** (기본 문법 이해)  
* **한국투자증권 해외주식 계좌** (실전 매매 시 필요)  
* **Alpha Vantage** 등 무료 API 가입 (뉴스 및 시세 데이터 수집)  
* DB 설치(예: PostgreSQL) 혹은 **간단한 SQL** 사용 가능성

---

### **6\. 이런 분께 추천합니다**

* **파이썬 기반** 프로젝트를 좋아하는 실무 개발자  
* **직접 만든 투자 알고리즘**으로 모의투자를 하고 싶은 투자자  
* AI/머신러닝, 빅데이터 프로젝트에 **금융 데이터**를 접목해보고 싶은 분

---

## **마무리**

본 강의는 **나스닥 상위 25개 종목**을 대상으로 한 실제 사례를 통해 **데이터 수집, 예측, 분석, 매매**의 모든 과정을 체계적으로 배우도록 설계되었습니다.

**자동매매 시스템**에 관심 있는 분이라면 누구나 실전에서 바로 적용 가능한 지식과 기술을 얻을 수 있습니다.

함께 배워나가며, 안정성과 수익성을 동시에 추구해 봅시다\!

강의에서 뵙겠습니다.

감사합니다\!

# **II. 주식 기본 개념 이해하기**

\<aside\> 💡

\</aside\>

주식 투자는 처음 접하는 사람에게 낯설고 복잡하게 느껴질 수 있습니다. 특히 미국 주식은 한국 주식과 다른 시장 구조, 용어, 그리고 경제 환경을 가지고 있어 더욱 그렇습니다. 하지만 기본 개념을 하나씩 이해하면 누구나 쉽게 시작할 수 있습니다. 이 강의자료는 미국 주식 투자의 기초 내용 다루며, 초보자가 실전에 뛰어들기 전에 꼭 알아야 할 내용을 상세히 설명합니다.

---

## **1\. 주식이란?**

**주식**은 기업이 자금을 모으기 위해 발행하는 소유권 증서입니다. 주식을 구매하면 그 기업의 일부를 소유하게 되어 **주주**가 됩니다. 주주는 기업이 이익을 내면 **배당금**을 받을 수 있고, 주식 가격이 오르면 매도하여 **차익**을 얻을 수 있습니다.

### **주식의 종류**

* **보통주 (Common Stock)**  
  * 기업의 의사결정에 참여할 수 있는 권리(예: 주주총회 투표권)가 있습니다.  
  * 배당금은 기업의 이익에 따라 변동됩니다.  
  * 일반적으로 우리가 말하는 ‘주식’은 보통주를 의미합니다.  
  * **예시**: 애플(Apple Inc.)의 보통주는 AAPL이라는 티커로 거래되며, 주주들은 애플의 연례 주주총회에서 투표권을 행사할 수 있습니다.  
* **우선주 (Preferred Stock)**  
  * 의사결정 권리는 없지만, 배당금을 보통주보다 먼저 받습니다.  
  * 기업이 파산하거나 청산될 때 자산 분배에서도 우선권을 가집니다.  
  * 안정적인 수익을 원하는 투자자에게 적합합니다.  
  * **예시**: Bank of America의 우선주는 BAC.PRL이라는 티커로 거래되며, 연간 고정 배당금을 제공합니다. 삼성전자를 예시로 들면 “삼성전자”라는 주식과 "삼성전자(우)"라는 주식이 있는 “(우)”가 붙은 것은 우선주라는 의미입니다.

### **주식의 역할**

* **기업 입장**: 주식을 발행해 자금을 조달하고 사업을 확장합니다.

  * **예시**: 테슬라(TSLA)는 주식 발행을 통해 전기차 생산 공장을 확장했습니다.  
* **투자자 입장**: 주식을 통해 기업의 성장에 투자하고 수익을 기대합니다.

  * **예시**: 아마존(AMZN) 주식을 초기 상장 시점에 매수한 투자자는 현재 수십 배의 수익을 얻었습니다.  
* **우리가 미국 주식을 해야 되는 이유:** 대한민국 주식 시장에서는 유상증자가 자주 발생해서 주주들의 이익이 희석되는 경우가 많지만, 미국 주식 시장에서는 우량주 기준 유상증자가 거의 불가능에 가깝다고 볼 수 있고, 주주 이익 보호를 최우선 시 합니다. 이를 간단한 예시로 비교해 보겠습니다.

   **대한민국 예시)**

   2020년, 대한민국의 한 대기업이 자금 조달을 위해 유상증자를 했습니다. 기업의 시가총액은 그대로지만, 주식 수량이 늘어났기 때문에, 주주들은 지분율이 줄어들어 주식 가치가 희석됐고, 이로 인해 주주들 사이에 불만이 생겼습니다. 결국 이후 주가도 하락했습니다.

   → 기업분할: S사의 배터리 사업의 잠재력을 보고 S사에 투자했는데, 기업 분할을 해버리는 경우도 존재…

   **미국 예시)**

   애플은 2020년에 자기 회사 주식을 시장에서 다시 사들이는 데 720억 달러(약 90조 원 정도)를 사용했습니다. 이걸 **자사주 매입**(Buyback)이라고 합니다. 유상증자(새로운 주식을 발행해서 돈을 모으는 것)를 하지 않고, 이미 회사에 쌓인 현금이나 수익을 활용해서 주식을 샀다는 뜻입니다. 이렇게 하면 주가가 오르고 주주들에게 이점이 많아서 "주주 가치를 높였다"고 표현합니다.

   **예시로 이해하기**

  * 애플이 2020년에 720억 달러로 자사주를 샀다고 해볼게요. 당시 주가가 약 120달러였다면, 약 **6억 주**(720억 ÷ 120)를 사들인 셈이에요.  
  * 총 주식이 170억 주였다면, 6억 주를 사들이고 나면 164억 주로 줄어요.  
  * 그럼 주당 이익(EPS)이 올라가고, 시장에서 "애플 주식이 더 귀해졌다"는 인식이 생겨 주가가 더 오를 가능성이 커져요.  
  * 실제로 애플은 2012년부터 2023년까지 약 6,750억 달러를 자사주 매입에 썼고, 주식 수는 약 25% 줄었어요. 그 결과 주가는 2012년 20달러(분할 조정 후)에서 2023년 190달러까지 올랐어요.  
* **차이점)**

  * **대한민국**: 유상증자가 잦아 주주들이 추가 부담을 지고 이익이 희석됨.  
  * **미국**: 유상증자 대신 채권 발행이나 자사주 매입 같은 방법을 선호하며 주주 이익을 우선시함.  
* 미국의 발달된 자본 시장과 주주 보호 문화 덕분에 유상증자가 드문 반면, 대한민국에서는 자금 조달 방식으로 유상증자가 더 흔히 사용됩니다.

---

## **2\. 미국 주식 시장**

미국 주식 시장은 세계에서 가장 크고 유동성이 높은 시장으로, 주로 뉴욕 증권거래소(NYSE)와 나스닥(NASDAQ)에서 거래됩니다. 이 두 시장은 각각의 특징과 상장된 기업 유형이 다릅니다.

### **2.1. 뉴욕 증권거래소 (NYSE)**

* **특징**:  
  * 세계에서 가장 오래되고 큰 증권거래소입니다(1792년 설립).  
  * 주로 대형 기업, 블루칩 기업(안정적인 대기업)이 상장되어 있습니다.  
  * 거래 방식: 경매식 거래(Auction Market)로, 전문 중개인(스페셜리스트)이 거래를 중개합니다.  
* **상장 기업 예시**:  
  * 코카콜라(KO): 음료 산업의 대표 기업으로, 안정적인 배당금을 제공합니다.  
  * 월마트(WMT): 세계 최대 유통업체로, 꾸준한 매출 성장을 보여줍니다.  
  * 제너럴 일렉트릭(GE): 산업 및 에너지 분야의 전통적인 대기업입니다.

### **2.2. 나스닥 (NASDAQ)**

* **특징**:  
  * 기술주, 성장주 중심의 시장입니다(1971년 설립).  
  * 전자 거래 시스템을 통해 거래가 이루어져 빠르고 효율적입니다.  
  * 상대적으로 변동성이 높지만, 성장 가능성이 큰 기업이 많습니다.  
* **상장 기업 예시**:  
  * 애플(AAPL): 스마트폰과 기술 혁신의 선두주자입니다.  
  * 마이크로소프트(MSFT): 소프트웨어와 클라우드 컴퓨팅의 리더입니다.  
  * 아마존(AMZN): 전자상거래와 클라우드 서비스로 급성장한 기업입니다.

### **2.3. 기타 시장**

* **OTC 시장 (Over-The-Counter)**:  
  * 거래소 밖에서 이루어지는 거래로, 소규모 기업이나 상장 요건을 충족하지 못한 기업의 주식이 거래됩니다.  
  * **예시**: OTCQX에서 거래되는 Nestle(NSTLY)는 미국 외 기업이지만 OTC를 통해 투자 가능합니다.  
  * **특징**: 유동성이 낮고 변동성이 크다..

### **2.4. 미국 주식 시장의 거래 시간**

**정규 거래 시간**

* **미국 동부 시간 (ET)**: 오전 9:30 \~ 오후 4:00  
* **한국 시간 (KST)**: 밤 10:30 \~ 다음 날 새벽 5:00  
  * **예시**: 미국에서 오전 9:30에 시장이 열리면 한국에서는 같은 날 밤 10:30입니다.

**장 전 거래 (Pre-Market)**

* **미국 동부 시간 (ET)**: 오전 4:00 \~ 오전 9:30  
* **한국 시간 (KST)**: 오후 5:00 \~ 밤 10:30  
  * **예시**: 미국에서 장 전 거래가 오전 4:00에 시작되면 한국에서는 오후 5:00입니다.

**장 후 거래 (Post-Market)**

* **미국 동부 시간 (ET)**: 오후 4:00 \~ 오후 8:00  
* **한국 시간 (KST)**: 새벽 5:00 \~ 오전 9:00  
  * **예시**: 미국에서 장 후 거래가 오후 4:00에 시작되면 한국에서는 새벽 5:00입니다.

---

### **서머타임(DST) 적용 시 주의사항**

* **적용 기간**: 미국은 매년 3월 둘째 주 일요일 \~ 11월 첫째 주 일요일 동안 서머타임을 적용합니다.  
* **시차 변화**: 서머타임 적용 시 한국과 미국 동부 시간의 시차가 13시간에서 14시간으로 늘어납니다.  
  * **정규 거래 시간 (서머타임 적용 시)**: 한국 시간으로 밤 11:30 \~ 다음 날 새벽 6:00.  
  * **예시**: 7월에 미국 시장이 오전 9:30(ET)에 열리면 한국에서는 밤 11:30(KST)입니다.

---

## **3\. 미국 주식 투자 용어**

### **3.1. 주식 용어 정리**

미국 주식 투자를 시작하려면 기본적인 용어를 이해하는 것이 필수입니다. 아래는 초보자가 반드시 알아야 할 용어와 예시입니다.

* **Ticker Symbol (티커 심볼)**: 주식을 식별하는 고유 코드.  
  * **예시**: 구글은 GOOGL, 페이스북(메타)은 META입니다.  
* **Stock Price (주가)**: 주식 한 주의 가격.  
  * **예시**: 2025년 3월 28일 기준 애플(AAPL)의 주가는 약 217.9달러입니다.  
* **Market Capitalization (시가총액)**: 기업의 총 주식 수 × 주가. 기업의 시장 가치를 나타냅니다.  
  * **예시**: 마이크로소프트(MSFT)의 시가총액은 약 2.75조 달러로, 발행 주식 수 약 75억 주 × 주가 **370**달러로 계산됩니다. → 2.75조 달려 \= 75억주 x 370달러  
* **Volume (거래량)**: 특정 기간 동안 거래된 주식의 수량.  
  * **예시**: 애플의 하루 거래량이 8천만 주라면 그날 시장의 관심이 높았음을 의미합니다.  
* **Bull Market (강세장)**: 주가가 상승하는 시장.  
  * **예시**: 2020년 하반기 기술주 중심의 강세장.  
* **Bear Market (약세장)**: 주가가 하락하는 시장.  
  * **예시**: 2008년 금융위기 당시의 약세장.

**Dividend (배당금)**

* **정의**: 기업이 벌어들인 이익의 일부를 주주들에게 나눠주는 돈입니다. 주로 현금으로 지급되며, 기업이 안정적일수록 배당금을 잘 주는 경향이 있습니다.  
* **최신 예시**: 존슨앤존슨(JNJ)은 2024년 기준으로 주당 연간 배당금을 약 **4.76달러**로 지급하고 있습니다(2023년 4.52달러에서 약간 인상된 수치로 추정). 이는 JNJ가 매년 배당금을 조금씩 늘리는 안정적인 배당주라는 뜻입니다.  
* **쉽게 이해하기**: 배당금은 주식을 가지고 있는 것만으로도 주주가 받는 "보너스" 같은 개념이에요. 예를 들어, JNJ 주식 100주를 가지고 있다면 연간 약 476달러(세전)를 받는 셈입니다.

**Dividend Yield (배당수익률)**

* **정의**: 배당금이 주가 대비 얼마나 되는지를 백분율로 나타낸 값입니다. 투자한 돈 대비 얼마나 배당으로 돌려받는지 보여줍니다.  
* **공식**: 배당수익률 \= (배당금 ÷ 주가) × 100  
* **최신 예시**: JNJ의 주가가 2025년 3월 31일 기준 약 **165달러**라고 가정하고, 배당금이 연간 4.76달러라면, 배당수익률은 (4.76 ÷ 165\) × 100 \= 약 2.88%입니다.  
* **쉽게 이해하기**: 만약 165달러를 투자했는데 1년에 4.76달러를 받으면, 투자한 돈의 2.88%를 배당으로 돌려받는다는 뜻이에요. 은행 이자율보다 높다면 매력적일 수 있죠\!

**Earnings Per Share (EPS, 주당순이익)**

* **정의**: **기업이 1년 동안 벌어들인 순이익을 총 주식 수로 나눈 값**입니다. **주식 1주가 얼마나 이익을 내는지 보여주는 지표로, 높을수록 기업이 돈을 잘 번다는 뜻**입니다.  
* **공식**: EPS \= 기업 순이익 ÷ 발행 주식 수  
* **최신 예시**: 아마존(AMZN)의 2024년 순이익이 약 **400억 달러**, 발행 주식 수가 약 **10.3억 주**라고 가정하면, EPS는 400억 ÷ 10.3억 \= 약 **38.83달러**입니다(2024년 실적 추정치 기반).  
* **쉽게 이해하기**: EPS는 주식 한 주가 "얼마나 돈을 버는지" 알려주는 숫자예요. 예를 들어, 아마존 주식 1주를 가지고 있으면 그 주식이 38.83달러어치 이익을 낸 셈이에요. 이 숫자가 높을수록 기업이 튼튼하다는 신호로 볼 수 있어요.  
* **보충 설명**: EPS가 마이너스면 기업이 적자라는 뜻이에요. 초보자는 EPS가 꾸준히 증가하는 기업을 찾으면 좋습니다.

**Price-to-Earnings Ratio (PER, 주가수익비율)**

* **정의**: 주가를 EPS로 나눈 값으로, **주식이 기업의 이익에 비해 비싼지 싼지를 판단하는 지표**입니다. **PER이 높으면 주가가 비싸다고 볼 수 있고, 낮으면 저평가되었다고 볼 수 있습니다.**  
* **공식**: PER \= 주가 ÷ EPS  
* **최신 예시**: 테슬라(TSLA)의 주가가 2025년 3월 31일 기준 약 **320달러**, 2024년 EPS가 약 **2.04달러**(최근 데이터 기준)라면, PER은 320 ÷ 2.04 \= 약 **157배**입니다. 이는 테슬라가 높은 성장성을 기대받아 비싸게 거래되고 있다는 뜻입니다.  
* **쉽게 이해하기**: PER은 "기업이 1달러를 벌 때 주가가 몇 배로 평가받는지"를 보여줘요. 테슬라의 PER이 157배라는 건, 투자자들이 1달러 이익에 157달러를 기꺼이 지불할 정도로 미래를 낙관한다는 의미예요. 반면, PER이 10\~20배인 기업은 더 안정적이고 저렴해 보일 수 있어요.  
* **보충 설명**: PER이 너무 높으면 거품일 가능성이 있고, 너무 낮으면 성장성이 낮거나 문제가 있는 기업일 수 있어요. 산업 평균과 비교해보는 게 중요합니다(예: 기술주는 30~~50배, 제조업은 10~~20배가 평균).

**Price-to-Book Ratio (PBR, 주가순자산비율)**

* **정의**: 주가를 주당순자산(BPS)으로 나눈 값으로, **주식이 기업의 자산 가치에 비해 비싼지 싼지**를 나타냅니다. **PBR이 1보다 낮으면 자산 대비 저평가, 1보다 높으면 고평가**로 볼 수 있습니다.  
* **공식**: PBR \= 주가 ÷ BPS  
* **최신 예시**: 월마트(WMT)의 주가가 약 **80달러**, BPS가 약 **28달러**(2024년 추정치)라면, PBR은 80 ÷ 28 \= 약 **2.86배**입니다. 이는 월마트의 자산 가치보다 주가가 2.86배 높게 거래되고 있다는 뜻입니다.  
* **쉽게 이해하기**: PBR은 "기업의 장부 가치(자산 \- 부채)에 비해 주가가 몇 배냐"를 보여줘요. 월마트의 PBR이 2.86배라면, 시장이 월마트의 자산뿐만 아니라 브랜드, 미래 수익성 등을 높게 평가한다는 뜻이에요. PBR이 1 아래면 "기업을 싸게 살 수 있다"고 생각할 수 있어요.  
* **보충 설명**: BPS(Book-value Per Share, 주당순자산)는 기업의 자산에서 부채를 뺀 값을 주식 수로 나눈 거예요. 예를 들어, 기업이 건물, 현금 같은 자산이 100억 달러이고 빚이 40억 달러라면 순자산은 60억 달러, 주식이 10억 주면 BPS는 6달러가 됩니다.

---

### **3.2. 보충 설명 요약: 어려운 개념 쉽게 풀기**

* **EPS (주당순이익)**: "주식 한 주가 얼마나 돈을 버는지" 알려주는 숫자. 높을수록 좋음.  
* **PER (주가수익비율)**: "주식이 이익에 비해 비싼지 싼지" 보여줌. 숫자가 크면 비싸고, 작으면 저렴.  
* **BPS (주당순자산)**: "주식 한 주가 가진 자산 가치"를 뜻함. 기업의 "실물 가치"를 체크.  
* **PBR (주가순자산비율)**: "주가가 자산에 비해 몇 배로 거래되느냐"를 보여줌. 1 아래면 싸게 산다고 볼 수 있음.

---

### **3.3. 왜 이런 지표가 중요할까?**

* **EPS**: 기업이 돈을 잘 버는지 확인하는 첫걸음.  
* **PER**: 주식을 살 때 "지금 비싼가, 싼가" 판단하는 기준.  
* **BPS와 PBR**: 기업의 "실제 가치"와 "시장 평가"의 차이를 알려줘서 저평가된 주식을 찾는 데 유용.

### **3.4. 추가 용어**

* **Blue Chip Stocks**: 안정적이고 신뢰할 수 있는 대기업 주식.  
  * **예시**: IBM은 오랜 역사와 안정적인 수익으로 블루칩 주식으로 분류됩니다.  
* **Growth Stocks**: 높은 성장 잠재력을 가진 기업의 주식.  
  * **예시**: 엔비디아(NVDA)는 AI와 반도체 시장 성장으로 주목받는 성장주입니다.  
* **Value Stocks**: 저평가된 기업의 주식.  
  * **예시**: 포드(F)는 자동차 산업에서 저평가된 가치주로 평가받기도 합니다.  
* **IPO (Initial Public Offering)**: 기업이 처음으로 주식을 공개하여 거래소에 상장.  
  * **예시**: 2021년 리비안(RIVN)의 IPO는 전기차 열풍으로 큰 주목을 받았습니다.

---

## **4\. 미국 주식 투자 방법**

미국 주식 투자는 목적과 스타일에 따라 다양한 방법으로 접근할 수 있습니다.

### **4.1. 장기 투자**

* **목표**: 기업의 성장에 따라 주가가 오를 때까지 장기 보유.  
* **특징**: 단기 변동에 신경 쓰지 않고, 기업의 펀더멘털에 집중.  
* **예시**: 워런 버핏은 코카콜라(KO)를 1988년에 매수한 뒤 수십 년간 보유하며 배당과 주가 상승 수익을 얻고 있습니다.

### **4.2. 단기 투자**

* **목표**: 주가의 단기 변동을 활용해 차익 실현.  
* **특징**: 차트 분석(기술적 분석)을 통해 매매 타이밍 결정.  
* **예시**:  
  * **데이 트레이딩**: 테슬라 주가가 실적 발표 후 급등할 때 매수 후 당일 매도.  
  * **스윙 트레이딩**: 엔비디아 주가가 반도체 호재로 1주일간 상승할 때 매매.

### **4.3. 가치 투자**

* **목표**: 시장에서 저평가된 주식을 찾아 투자.  
* **특징**: 기업의 내재가치와 주가의 차이를 분석.  
* **예시**: 버크셔 해서웨이(BRK.B)는 저평가된 기업을 찾아 장기 투자하는 워런 버핏의 대표적인 사례입니다.

### **4.4. 성장 투자**

* **목표**: 미래에 큰 성장이 기대되는 기업에 투자.  
* **특징**: 현재 수익보다 성장 가능성에 주목.  
* **예시**: 아마존은 2000년대 초반 적자에도 불구하고 성장 가능성을 보고 투자한 이들이 큰 수익을 얻었습니다.

---

## **5\. 미국 주식 투자 시 고려해야 할 요소**

미국 주식 투자는 단순히 주식을 사고파는 것 이상으로, 다양한 요소를 분석해야 합니다.

### **5.1. 기업 분석**

* **재무제표 분석**  
  * **Income Statement (손익계산서)**: 매출, 비용, 순이익 확인.  
    * **예시**: 애플의 2022년 매출은 3,943억 달러로, 전년 대비 8% 증가.  
  * **Balance Sheet (대차대조표)**: 자산, 부채, 자본 파악.  
    * **예시**: 테슬라의 자산은 공장 확장으로 2022년 1,032억 달러를 기록.  
  * **Cash Flow Statement (현금흐름표)**: 현금 유입/유출 상태 분석.  
    * **예시**: 마이크로소프트는 연간 870억 달러의 운영 현금 흐름을 기록(2022년).  
* **산업 분석**: 기업이 속한 산업의 성장성과 경쟁 구도 평가.  
  * **예시**: 클라우드 컴퓨팅 산업의 성장으로 아마존(AWS)과 마이크로소프트(Azure)에 주목.  
* **경영진 분석**: CEO와 경영진의 역량과 비전 확인.  
  * **예시**: 일론 머스크의 혁신적인 리더십이 테슬라 주가에 긍정적 영향을 미침.

### **5.2. 경제 지표**

* **금리 (Interest Rates)**: 미국 연방준비제도(Fed)의 금리 정책이 주식 시장에 큰 영향을 미칩니다.  
  * **예시**: 2022년 Fed의 금리 인상으로 나스닥 기술주가 20% 이상 하락.  
* **인플레이션 (Inflation)**: 물가 상승이 기업 비용과 소비자 구매력에 영향.  
  * **예시**: 2022년 인플레이션으로 월마트(WMT)의 비용이 증가하며 주가 하락. (채권 몰림)  
* **GDP 성장률**: 경제 성장률이 높을수록 주식 시장 활성화.  
  * **예시**: 2021년 미국 GDP 성장률 5.7%로 주식 시장이 강세를 보임.  
* **환율**: 달러 강세/약세가 기업 수출 경쟁력에 영향.  
  * **예시**: 달러 강세 시 코카콜라(KO)의 해외 매출이 상대적으로 줄어듦.

### **5.3. 시장 심리**

* **투자자 심리**: 낙관적이면 주가 상승, 비관적이면 하락.  
  * **예시**: 2020년 COVID-19 초기 주가 폭락 후 백신 소식으로 급반등.  
* **뉴스와 이벤트**: 실적 발표, 정치적 사건 등이 주가에 영향.  
  * **예시**: 애플의 신제품 발표 후 주가가 5% 상승한 사례.

---

## **6\. 미국 주식 투자 전략**

### **6.1. 분산 투자**

* **목표**: 한 기업이나 산업에 집중하지 않고 리스크 분산.  
* **방법**: 기술(애플), 소비재(코카콜라), 금융(JP모건) 등 여러 섹터에 투자.  
* **예시**: S\&P 500 ETF(SPY)에 투자하면 500개 기업에 분산 투자 가능.

### **6.2. 정기적 투자**

* **목표**: 일정 주기로 투자해 평균 매입 단가를 낮춤(달러 코스트 애버리징).  
* **방법**: 매달 100달러씩 마이크로소프트(MSFT) 주식 매수.  
* **예시**: 주가가 300달러일 때 0.33주, 250달러일 때 0.4주 매수하여 평균 단가 낮춤.

### **6.3. 배당 투자**

* **목표**: 안정적인 배당금을 주는 기업에 투자해 현금 흐름 확보.  
* **방법**: 배당수익률 3% 이상인 P\&G(PG)나 AT\&T(T) 선정.  
* **예시**:  
  * **P\&G (PG)**:  
    * 연간 배당금: 약 4.03달러  
    * 주가: 약 170달러  
    * 배당수익률: 약 **2.37%**  
    * 특징: 안정적인 배당 성장주로, 매년 배당금을 조금씩 인상(68년 연속 증가).  
  * **AT\&T (T)**:  
    * 연간 배당금: 약 1.11달러  
    * 주가: 약 20달러  
    * 배당수익률: 약 **5.55%**  
    * 특징: 높은 배당수익률을 제공하지만, 성장성보다는 안정적인 현금 흐름에 초점.

### **6.4. ETF 투자**

* **목표**: 특정 지수나 섹터를 추종하는 ETF로 분산 효과와 편리함 누림.  
* **예시**: 나스닥 100을 추종하는 Invesco QQQ ETF는 기술주에 투자하는 쉬운 방법.

---

## **7\. 미국 주식 투자 시 주의사항**

미국 주식 투자는 수익만큼 리스크도 따릅니다.

* **환율 리스크**: 원화와 달러 간 환율 변동이 수익에 영향.  
  * **예시**: 달러가 1,200원에서 1,300원으로 강세 시 수익 증가.  
* **시차**: 미국 시장은 한국 시간 밤에 열림.  
  * **예시**: 실적 발표 후 급등락 시 실시간 대응 어려움.  
* **세금**: 배당금에 15% 원천징수세 부과.  
  * **예시**: 100달러 배당 시 15달러 세금 공제 후 85달러 수령.  
* **정보 접근성**: 영어 자료가 많아 언어 장벽 존재.  
  * **예시**: SEC 보고서를 읽으려면 영어 해석 필요.

---

## **8\. 미국 주식 투자 시작하기**

미국 주식 투자를 시작하려면 다음 단계를 따르세요.

### **8.1. 증권 계좌 개설**

* **증권사 선택**: 미국 주식 거래 가능한 증권사 선택.  
  * **예시**: 한국(미래에셋, 키움, 한국투자증권, 삼성증권), 미국(Robinhood, Fidelity).  
* **계좌 개설**: 앱 또는 웹사이트에서 신분증 제출 후 개설.

### **8.2. 주식 매매 방법**

* **매수 주문**: 티커, 수량, 가격 입력.  
  * **예시**: AAPL 5주를 시장가로 매수 시 약 900달러 소요.  
* **매도 주문**: 보유 주식 선택 후 매도.  
  * **예시**: AMZN 2주를 지정가 130달러로 매도 설정.

### **8.3. 투자 금액 결정**

* **원칙**: 잃어도 괜찮은 금액으로 시작.  
* **포트폴리오**: 3\~5개 종목 추천.  
  * **예시**: 1,000달러로 애플(400달러), 테슬라(300달러), 코카콜라(300달러) 분산.

---

 

# **III. 강의 자료**

# **목차**

\<aside\> 💡

\</aside\>

# **1\. 데이터 준비 및 DB 저장**

---

## **1.1. 대상 종목**

* [종목 선정 기준](https://www.notion.so/1ab7bcd170cf80e8819fe5e25b740594?pvs=21)  
* **종목**: 나스닥 탑 25개 종목 (예: 애플, 마이크로소프트, 아마존, 구글, 테슬라 등)  
* **선정 이유**: 나스닥 탑 25개 종목은 시가총액 기준으로 선정된 기술 중심의 대형주로, 시장의 흐름을 주도하며 변동성이 높아 단기 매매에 적합합니다. 또한, 경제 지표와 기술적 지표를 활용한 분석이 용이하고, 뉴스 감성 분석의 효과가 크기 때문에 AI 자동 매매 시스템에 적합한 특성을 가질 것으로 판단합니다.  
* **코드와의 연계**: 코드에서 STOCK\_TO\_TICKER 딕셔너리를 통해 애플, 마이크로소프트, 아마존, 구글, 테슬라 등 다양한 종목을 처리할 수 있으며, 이 중 나스닥 탑 25개 종목을 선정하여 분석 및 매매를 진행합니다.

---

## **1.2. 주식 예측 정보 준비**

* **설명**: AI 주식 자동 예측 모델을 통해 생성된 파일로, 주식 예측 정보를 포함합니다.  
* **컬럼 구성**:  
  * Stock: 종목명 (예: "TSLA", "AAPL")  
  * Accuracy (%): 예측 모델의 신뢰도 (0\~100% 사이 값)  
  * Last Actual Price: 예측 직전 종가  
  * Predicted Future Price: 모델이 예측한 다음 주가  
  * Rise Probability (%): 상승 확률 (퍼센트 단위로 계산)

---

## **1.3. DB 셋팅**

[테이블 DDL](https://www.notion.so/DDL-1ab7bcd170cf80389ffdeae54d0a8819?pvs=21)

### **테이블명: economic\_and\_stock\_data**

* **설명**: 경제 및 주식 관련 데이터를 저장하는 테이블로, 거시경제 지표와 주요 주식/지수 데이터를 포함.  
* 컬럼 구성: (펼쳐 보기)  
  1. 날짜: 데이터 기록 날짜 (Primary Key, DATE)  
  2. 10년 기대 인플레이션율: 10년 기대 인플레이션율 (NUMERIC)  
  3. 장단기 금리차: 장단기 금리 차이 (NUMERIC)  
  4. 기준금리: 기준 금리 (NUMERIC)  
  5. 미시간대 소비자 심리지수: 미시간대 소비자 심리지수 (NUMERIC)  
  6. 실업률: 실업률 (NUMERIC)  
  7. 2년 만기 미국 국채 수익률: 2년 만기 미국 국채 수익률 (NUMERIC)  
  8. 10년 만기 미국 국채 수익률: 10년 만기 미국 국채 수익률 (NUMERIC)  
  9. 금융스트레스지수: 금융 스트레스 지수 (NUMERIC)  
  10. 개인 소비 지출: 개인 소비 지출 (NUMERIC)  
  11. 소비자 물가지수: 소비자 물가지수 (NUMERIC)  
  12. 5년 변동금리 모기지: 5년 변동금리 모기지 (NUMERIC)  
  13. 미국 달러 환율: 미국 달러 환율 (NUMERIC)  
  14. 통화 공급량 M2: 통화 공급량 M2 (NUMERIC)  
  15. 가계 부채 비율: 가계 부채 비율 (NUMERIC)  
  16. GDP 성장률: GDP 성장률 (NUMERIC)  
  17. 나스닥 종합지수: 나스닥 종합지수 (NUMERIC)  
  18. S\&P 500 지수: S\&P 500 지수 (NUMERIC)  
  19. 금 가격: 금 가격 (NUMERIC)  
  20. 달러 인덱스: 달러 인덱스 (NUMERIC)  
  21. 나스닥 100: 나스닥 100 지수 (NUMERIC)  
  22. S\&P 500 ETF: S\&P 500 ETF 가격 (NUMERIC)  
  23. QQQ ETF: QQQ ETF 가격 (NUMERIC)  
  24. 러셀 2000 ETF: 러셀 2000 ETF 가격 (NUMERIC)  
  25. 다우 존스 ETF: 다우 존스 ETF 가격 (NUMERIC)  
  26. VIX 지수: VIX 지수 (NUMERIC)  
  27. 닛케이 225: 닛케이 225 지수 (NUMERIC)  
  28. 상해종합: 상해종합 지수 (NUMERIC)  
  29. 항셍: 항셍 지수 (NUMERIC)  
  30. 영국 FTSE: 영국 FTSE 지수 (NUMERIC)  
  31. 독일 DAX: 독일 DAX 지수 (NUMERIC)  
  32. 프랑스 CAC 40: 프랑스 CAC 40 지수 (NUMERIC)  
  33. 미국 전체 채권시장 ETF: 미국 전체 채권시장 ETF 가격 (NUMERIC)  
  34. TIPS ETF: TIPS ETF 가격 (NUMERIC)  
  35. 투자등급 회사채 ETF: 투자등급 회사채 ETF 가격 (NUMERIC)  
  36. 달러/엔: 달러/엔 환율 (NUMERIC)  
  37. 달러/위안: 달러/위안 환율 (NUMERIC)  
  38. 미국 리츠 ETF: 미국 리츠 ETF 가격 (NUMERIC)  
  39. 애플: 애플 주가 (NUMERIC)  
  40. 마이크로소프트: 마이크로소프트 주가 (NUMERIC)  
  41. 아마존: 아마존 주가 (NUMERIC)  
  42. 구글 A: 구글 A 주가 (NUMERIC)  
  43. 구글 C: 구글 C 주가 (NUMERIC)  
  44. 메타: 메타 주가 (NUMERIC)  
  45. 테슬라: 테슬라 주가 (NUMERIC)  
  46. 엔비디아: 엔비디아 주가 (NUMERIC)  
  47. 코스트코: 코스트코 주가 (NUMERIC)  
  48. 넷플릭스: 넷플릭스 주가 (NUMERIC)  
  49. 페이팔: 페이팔 주가 (NUMERIC)  
  50. 인텔: 인텔 주가 (NUMERIC)  
  51. 시스코: 시스코 주가 (NUMERIC)  
  52. 컴캐스트: 컴캐스트 주가 (NUMERIC)  
  53. 펩시코: 펩시코 주가 (NUMERIC)  
  54. 암젠: 암젠 주가 (NUMERIC)  
  55. 허니웰 인터내셔널: 허니웰 인터내셔널 주가 (NUMERIC)  
  56. 스타벅스: 스타벅스 주가 (NUMERIC)  
  57. 몬델리즈: 몬델리즈 주가 (NUMERIC)  
  58. 마이크론: 마이크론 주가 (NUMERIC)  
  59. 브로드컴: 브로드컴 주가 (NUMERIC)  
  60. 어도비: 어도비 주가 (NUMERIC)  
  61. 텍사스 인스트루먼트: 텍사스 인스트루먼트 주가 (NUMERIC)  
  62. AMD: AMD 주가 (NUMERIC)  
  63. 어플라이드 머티리얼즈: 어플라이드 머티리얼즈 주가 (NUMERIC)  
* **저장 로직**:  
  1. 경제 지표 및 주식 데이터를 외부 API(예: FRED, Yahoo Finance)에서 수집.  
  2. 날짜별로 데이터를 economic\_and\_stock\_data 테이블에 저장.

---

### **테이블명: access\_tokens**

* **설명**: 한국투자증권 API 접근 토큰 정보를 저장하는 테이블.  
* 컬럼 구성: (펼쳐 보기)  
  1. id: 자동 증가하는 고유 식별자 (Primary Key, SERIAL)  
  2. access\_token: API 접근을 위한 JWT 토큰 (TEXT)  
  3. created\_at: 토큰 생성 시간 (TIMESTAMP WITH TIME ZONE, 기본값: 현재 시간)  
  4. expiration\_time: 토큰 만료 시간 (TIMESTAMP WITH TIME ZONE)  
  5. is\_active: 토큰 활성 상태 (BOOLEAN, 기본값: True)  
* **저장 로직**:  
  1. 한국투자증권 API 인증 요청을 통해 토큰 발급.  
  2. 발급된 토큰과 만료 시간을 access\_tokens 테이블에 저장.  
  3. 주기적으로 만료된 토큰을 비활성화(is\_active \= False) 처리.

---

### **테이블명: predicted\_stocks**

* **설명**: 주식 예측 및 실제 가격 데이터를 저장하는 테이블.  
* 컬럼 구성: (펼쳐 보기)  
  1. id: 자동 증가하는 고유 식별자 (Primary Key, SERIAL)  
  2. 날짜: 예측 데이터의 날짜 (DATE, UNIQUE)  
  3. 애플\_Predicted: 애플 예측 주가 (NUMERIC)  
  4. 애플\_Actual: 애플 실제 주가 (NUMERIC)  
  5. 마이크로소프트\_Predicted: 마이크로소프트 예측 주가 (NUMERIC)  
  6. 마이크로소프트\_Actual: 마이크로소프트 실제 주가 (NUMERIC)  
  7. 아마존\_Predicted: 아마존 예측 주가 (NUMERIC)  
  8. 아마존\_Actual: 아마존 실제 주가 (NUMERIC)  
  9. 구글 A\_Predicted: 구글 A 예측 주가 (NUMERIC)  
  10. 구글 A\_Actual: 구글 A 실제 주가 (NUMERIC)  
  11. 구글 C\_Predicted: 구글 C 예측 주가 (NUMERIC)  
  12. 구글 C\_Actual: 구글 C 실제 주가 (NUMERIC)  
  13. 메타\_Predicted: 메타 예측 주가 (NUMERIC)  
  14. 메타\_Actual: 메타 실제 주가 (NUMERIC)  
  15. 테슬라\_Predicted: 테슬라 예측 주가 (NUMERIC)  
  16. 테슬라\_Actual: 테슬라 실제 주가 (NUMERIC)  
  17. 엔비디아\_Predicted: 엔비디아 예측 주가 (NUMERIC)  
  18. 엔비디아\_Actual: 엔비디아 실제 주가 (NUMERIC)  
  19. 코스트코\_Predicted: 코스트코 예측 주가 (NUMERIC)  
  20. 코스트코\_Actual: 코스트코 실제 주가 (NUMERIC)  
  21. 넷플릭스\_Predicted: 넷플릭스 예측 주가 (NUMERIC)  
  22. 넷플릭스\_Actual: 넷플릭스 실제 주가 (NUMERIC)  
  23. 페이팔\_Predicted: 페이팔 예측 주가 (NUMERIC)  
  24. 페이팔\_Actual: 페이팔 실제 주가 (NUMERIC)  
  25. 인텔\_Predicted: 인텔 예측 주가 (NUMERIC)  
  26. 인텔\_Actual: 인텔 실제 주가 (NUMERIC)  
  27. 시스코\_Predicted: 시스코 예측 주가 (NUMERIC)  
  28. 시스코\_Actual: 시스코 실제 주가 (NUMERIC)  
  29. 컴캐스트\_Predicted: 컴캐스트 예측 주가 (NUMERIC)  
  30. 컴캐스트\_Actual: 컴캐스트 실제 주가 (NUMERIC)  
  31. 펩시코\_Predicted: 펩시코 예측 주가 (NUMERIC)  
  32. 펩시코\_Actual: 펩시코 실제 주가 (NUMERIC)  
  33. 암젠\_Predicted: 암젠 예측 주가 (NUMERIC)  
  34. 암젠\_Actual: 암젠 실제 주가 (NUMERIC)  
  35. 허니웰 인터내셔널\_Predicted: 허니웰 인터내셔널 예측 주가 (NUMERIC)  
  36. 허니웰 인터내셔널\_Actual: 허니웰 인터내셔널 실제 주가 (NUMERIC)  
  37. 스타벅스\_Predicted: 스타벅스 예측 주가 (NUMERIC)  
  38. 스타벅스\_Actual: 스타벅스 실제 주가 (NUMERIC)  
  39. 몬델리즈\_Predicted: 몬델리즈 예측 주가 (NUMERIC)  
  40. 몬델리즈\_Actual: 몬델리즈 실제 주가 (NUMERIC)  
  41. 마이크론\_Predicted: 마이크론 예측 주가 (NUMERIC)  
  42. 마이크론\_Actual: 마이크론 실제 주가 (NUMERIC)  
  43. 브로드컴\_Predicted: 브로드컴 예측 주가 (NUMERIC)  
  44. 브로드컴\_Actual: 브로드컴 실제 주가 (NUMERIC)  
  45. 어도비\_Predicted: 어도비 예측 주가 (NUMERIC)  
  46. 어도비\_Actual: 어도비 실제 주가 (NUMERIC)  
  47. 텍사스 인스트루먼트\_Predicted: 텍사스 인스트루먼트 예측 주가 (NUMERIC)  
  48. 텍사스 인스트루먼트\_Actual: 텍사스 인스트루먼트 실제 주가 (NUMERIC)  
  49. AMD\_Predicted: AMD 예측 주가 (NUMERIC)  
  50. AMD\_Actual: AMD 실제 주가 (NUMERIC)  
  51. 어플라이드 머티리얼즈\_Predicted: 어플라이드 머티리얼즈 예측 주가 (NUMERIC)  
  52. 어플라이드 머티리얼즈\_Actual: 어플라이드 머티리얼즈 실제 주가 (NUMERIC)  
  53. S\&P 500 ETF\_Predicted: S\&P 500 ETF 예측 가격 (NUMERIC)  
  54. S\&P 500 ETF\_Actual: S\&P 500 ETF 실제 가격 (NUMERIC)  
  55. QQQ ETF\_Predicted: QQQ ETF 예측 가격 (NUMERIC)  
  56. QQQ ETF\_Actual: QQQ ETF 실제 가격 (NUMERIC)  
  57. created\_at: 데이터 생성 시간 (TIMESTAMP WITH TIME ZONE, 기본값: 현재 시간)  
* **저장 로직**:  
  1. 머신러닝 모델을 통해 나스닥 탑 25개 종목 및 ETF의 예측 주가를 생성.  
  2. 실제 주가와 함께 predicted\_stocks 테이블에 저장.

---

### **테이블명: ticker\_sentiment\_analysis**

* **설명**: 종목별 뉴스 감성 분석 결과를 저장하는 테이블.  
* 컬럼 구성: (펼쳐 보기)  
  1. id: 자동 증가하는 고유 식별자 (Primary Key, SERIAL)  
  2. ticker: 종목 티커 (VARCHAR(10))  
  3. average\_sentiment\_score: 평균 감성 점수 (FLOAT)  
  4. article\_count: 관련 기사 수 (INTEGER)  
  5. calculation\_date: 계산 날짜 (TIMESTAMP)  
  6. created\_at: 데이터 생성 시간 (TIMESTAMP, 기본값: 현재 시간)  
* **저장 로직**:  
  1. 뉴스 데이터를 수집하여 감성 분석 수행.  
  2. 종목 별 감성 점수를 전부 다 더한 값을 기사 수로 나누는 로직 수행  
  3. 결과를 ticker\_sentiment\_analysis 테이블에 저장.

---

### **테이블명: stock\_recommendations**

* **설명**: 기술적 분석을 기반으로 한 주식 추천 정보를 저장하는 테이블.  
* 컬럼 구성: (펼쳐 보기)  
  1. 날짜: 분석 날짜 (DATE, Primary Key 일부)  
  2. 종목: 종목명 (VARCHAR(50), Primary Key 일부)  
  3. SMA20: 20일 단순 이동평균 (NUMERIC)  
  4. SMA50: 50일 단순 이동평균 (NUMERIC)  
  5. 골든\_크로스: 골든 크로스 여부 (BOOLEAN)  
  6. RSI: 상대강도지수 (NUMERIC)  
  7. MACD: MACD 지표 (NUMERIC)  
  8. Signal: MACD Signal 라인 (NUMERIC)  
  9. MACD\_매수\_신호: MACD 매수 신호 여부 (BOOLEAN)  
  10. 추천\_여부: 추천 여부 (BOOLEAN)  
* **저장 로직**:  
  1. 종목별 기술적 지표(SMA, RSI, MACD 등)를 계산.  
  2. 골든 크로스, MACD 매수 신호 등을 기반으로 추천 여부 판단.  
  3. 결과를 stock\_recommendations 테이블에 저장.

---

# **2\. 매매 로직 구성**

## **2.1. 데이터 및 지표 수집**

* **가격 데이터 소스**:  
  * Fred API, Yahoo API 를 활용해 경제 지표, 주가 지표 수집.  
* **기술적 지표 계산 (종가를 기준으로 계산)**:  
  * **페이지 참조:** [기술적 지표](https://www.notion.so/1b77bcd170cf80d2939cd51e993a9993?pvs=21)  
  * **RSI**: 14일 기준으로 계산 (calculate\_rsi).  
  * **이동평균선**: SMA20(20일 단순 이동평균), SMA50(50일 단순 이동평균) 계산 (calculate\_sma).  
  * **MACD**: 12일 EMA, 26일 EMA, 9일 Signal 라인 기준 계산 (calculate\_macd).  
* **뉴스 데이터**:  
  * **페이지 참조: [Alpha Vantage](https://www.notion.so/Alpha-Vantage-1b17bcd170cf80198c2fe3eb7c9cb993?pvs=21), [Alpha Vantage API](https://www.notion.so/Alpha-Vantage-API-1b77bcd170cf8025bfcae978f63d267c?pvs=21)**  
  * Alpha Vantage API(NEWS\_SENTIMENT 함수)를 통해 종목별 뉴스 감정 데이터를 수집합니다.  
  * 감정 점수는 \-1(부정)에서 \+1(긍정) 사이로 분류됩니다.  
  * 5단계 구간으로 매수 매도 신호 분류

---

## **2.2. 매수 (구매) 로직**

[매수 추천 종목 선정 기준](https://www.notion.so/1b87bcd170cf8016a930c451ea36d2d9?pvs=21)

### **2.2.1. 예측 정보 기반 필터링**

* **조건**:  
  * Rise Probability (%) ≥ 3%  
  * Accuracy (%) ≥ 80%  
* **실행**: 조건을 충족하면 매수 대상으로 선정 (StockRecommendationService.get\_stock\_recommendations).

### **2.2.2. 기술적 지표 확인**

* **골든 크로스**:  
  * SMA20 \> SMA50 (generate\_technical\_recommendations에서 계산).  
* **RSI**:  
  * RSI \< 50 (과매도 구간 확인).  
* **MACD**:  
  * MACD \> Signal 라인 (매수 신호).

**보강 및 수정**:

* 코드에서 기술적 지표는 generate\_technical\_recommendations 함수를 통해 계산.

### **2.2.3. 뉴스 감성 분석**

* **수집**: Alpha Vantage API를 통해 뉴스 데이터를 가져옵니다.  
* **분석**: 평균 감정 점수 ≥ 0.15인 경우 긍정으로 간주 (fetch\_and\_store\_sentiment\_for\_recommendations).

### **2.2.4. 매수 실행**

* **실행**: 한국투자증권 API(order\_overseas\_stock)를 통해 매수 주문을 실행합니다.

**주문 데이터 예시**:

 {  
  "CANO": "계좌번호",  
  "ACNT\_PRDT\_CD": "상품코드",  
  "OVRS\_EXCG\_CD": "NASD",  
  "PDNO": "QQQ",  
  "ORD\_QTY": "10",  
  "OVRS\_ORD\_UNPR": "300.00",  
  "ORD\_DVSN": "00",  
  "is\_buy": true  
}

* 

---

## **2.3. 매도 로직**

[매도 로직 구체화](https://www.notion.so/1be7bcd170cf80a1a805d8f60a208477?pvs=21)

### **2.3.1. 뉴스 감성 분석 (매도 전 체크)**

* **수집**: Alpha Vantage API로 뉴스 데이터를 수집.  
* **분석**: 평균 감정 점수 \< \-0.15인 경우 부정으로 간주 (get\_recommendations\_with\_sentiment).  
* **실행**: 부정적인 경우 매도 고려.

### **2.3.2. 가격 기반 주문 (익절 / 손절)**

* **익절 매도**:  
  * 매수 가격 × 1.05 (+5%)에 매도 주문 설정 (overseas\_order\_resv).  
* **손절 매도**:  
  * 매수 가격 × 0.95 (-5%)에 손절 주문 설정.

### **2.3.3. 기술적 지표 기반 매도 조건**

* **데드 크로스**:  
  * SMA20 \< SMA50.  
* **RSI**:  
  * RSI \> 70 (과매수 구간).  
* **MACD**:  
  * MACD \< Signal 라인 (매도 신호).

---

# **3\. 최종 로직 흐름 요약**

## **3.1. 매수 대상 평가 및 실행**

1. **필터링**: Rise Probability (%) ≥ 3%, Accuracy (%) ≥ 80%.  
2. **기술적 지표 확인**: 골든 크로스, RSI \< 50, MACD \> Signal.  
3. **뉴스 감성 분석**: 평균 감정 점수 ≥ 0.15.  
4. 한국투자증권 API로 매수 주문 실행.  
* 매수 대상 선정  
  * 1번 통과 \+ 3번 만족 \+ 2번 항목 중 1개 이상 만족  
  * 1번 통과 \+ 2번 항목 중 2개 이상 만족

실제 투자 매수 대상 스케줄러 API (실행 또는 종료)

* 한국 시간 기준 밤 12시에 작동  
* 매수 대상: get\_combined\_recommendations\_with\_technical\_and\_sentiment() 함수 호출하여 종목 추출

1번 통과 \+ 3번 만족 \+ 2번 항목 중 2개 이상 만족 1번 통과 \+ 2번 항목 중 3개 이상 만족

* 위 매수 대상에 해당하는 종목에 대해 API ([\*\*/balance/quotations/price](http://localhost:8000/docs#/%EC%9E%94%EA%B3%A0/get_current_price_route_balance_quotations_price_get)\*\* 해외주식 현재체결가 조회) 호출하여 현재 체결가로 매수 주문하기.

## **3.2. 매도 대상 평가 및 실행**

1. 보유 종목의 Rise Probability (%), Accuracy (%)  
2. **가격 기반**: \+5% 예약 매도, \-5% 손절 예약.  
3. **뉴스 감성 분석**: 평균 감정 점수 \< \-0.15 시 매도 고려.  
4. **기술적 지표 확인**: 데드 크로스, RSI \> 70, MACD \< Signal.  
5. 한국투자증권 API로 매도 주문 실행.  
* 매도 대상 선정  
  * **조건 1**: 가격이 \+5% (익절) 또는 \-5% (손절)에 도달. → 매도  
  * **조건 2**: 감성 점수 \< \-0.15 이고 기술적 지표 중 2개 이상 매도 신호. → 현재가 기준 매도  
  * **조건 3**: 기술적 지표 중 3개 이상 매도 신호. → 현재가 기준 매도

실제 매도 대상 스케줄러 API (실행 또는 종료)

매도 대상은 get\_stocks\_to\_sell() 함수 호출하여 매도 대상 종목 추출

1. 장중에 1분에 한번씩 스케줄러가 내가 보유한 종목에 대해 해외 주식 잔고를 조회하며,  
2. 내가 보유한 종목에 대해 잔고를 조회하여 종목의 가격이 \-5% 이하이면 매도, \+5% 이상이면 매도한다.  
3. 그리고 \-5% 이하 또는 \+5% 이상이 아니더라도 아래 조건을 만족하면 그냥 매도한다.

**→ 조건 2**: 감성 점수 \< \-0.15 이고 기술적 지표 중 2개 이상 매도 신호. → 현재가 기준 매도

**→ 조건 3**: 기술적 지표 중 3개 이상 매도 신호. → 현재가 기준 매도

---

# **4\. 추가 고려 사항**

## **4.1. 한국투자증권 주식계좌 준비**

[한투 해외주식계좌 개설](https://www.notion.so/1b87bcd170cf80c99766f94d80d1ab63?pvs=21)

## **4.2. API 호출 관리**

* **제한 고려**: Alpha Vantage API 호출 제한(예: 초당 5회)을 준수해야 합니다.

---

# **5\. 결론**

* **알고리즘 개요**:  
  * 예측 정보(stock\_analysis\_results), 기술적 지표(stock\_recommendations), 뉴스 감성 분석(ticker\_sentiment\_analysis)을 종합적으로 활용.  
  * 나스닥 상위 25개 종목을 대상으로 AI 기반 자동 매매 시스템 구현.  
  * 한국투자증권 API를 통해 실제 자동 매매 실행.  
* **목표**:  
  * 안정성과 수익성을 동시에 추구.  
  * 모의투자를 통해 알고리즘 검증 후 실전 투자 적용.  
* **특징**:  
  * 실전 투자 전 충분한 검증 가능.  
  * 코드 기반으로 세부 조정 유연성 제공.

—------- 아래는 위 문서를 참고하는 자료문서 —------------------------------------------------------------------

# **종목 선정 기준**

이 지표들은 거시경제 상황(금리, 인플레이션, 소비자 심리 등), 금융 시장 리스크(VIX, 금융스트레스지수), 환율 변동 등을 반영합니다. 따라서 이러한 지표와 상관관계가 높은 종목을 선정하는 것이 예측 정확도를 높이는 데 중요합니다.

### **종목 선정 기준**

1. **경제 지표 민감도**: 금리, 인플레이션, 소비자 심리, 환율 등 주요 지표에 민감하게 반응하는 종목.  
2. **시장 대표성**: 나스닥 100에서 시가총액 상위권에 속하며 시장 지수(S\&P 500, 나스닥 종합지수)와 높은 상관관계를 보이는 대형주.  
3. **섹터 다양성**: 기술, 소비재, 헬스케어, 통신 등 다양한 섹터를 포함하여 경제 지표의 영향을 폭넓게 반영.  
4. **기업 특성**:  
   * 금리 민감도(성장주, 고PER 종목),  
   * 소비자 심리 의존도(소비재, 서비스),  
   * 인플레이션 영향(필수 소비재, 헬스케어),  
   * 환율 민감도(수출 비중 높은 글로벌 기업).

\# 나스닥 100 상위 종목 티커 리스트와 한글 이름 (경제 지표 기반 예측에 적합한 20개 종목 선정)  
nasdaq\_top\_100 \= \[  
    ("AAPL", "애플"),                      \# 1위, 9.50%  
    ("MSFT", "마이크로소프트"),            \# 3위, 7.67%  
    ("AMZN", "아마존"),                    \# 4위, 5.80%  
    ("GOOGL", "구글 A"),                   \# 10위, 2.58%  
    ("GOOG", "구글 C"),                    \# 11위, 2.48%  
    ("META", "메타"),                      \# 6위, 3.79%  
    ("TSLA", "테슬라"),                    \# 8위, 2.76%  
    ("NVDA", "엔비디아"),                  \# 2위, 7.95%  
    ("COST", "코스트코"),                  \# 7위, 2.97%  
    ("NFLX", "넷플릭스"),                  \# 9위, 2.68%  
    ("PYPL", "페이팔"),                    \# 51위, 0.46%  
    ("INTC", "인텔"),                      \# 36위, 0.65%  
    ("CSCO", "시스코"),                    \# 13위, 1.63%  
    ("CMCSA", "컴캐스트"),                 \# 27위, 0.88%  
    ("PEP", "펩시코"),                     \# 15위, 1.35%  
    ("AMGN", "암젠"),                      \# 23위, 1.06%  
    ("HON", "허니웰 인터내셔널"),           \# 26위, 0.89%  
    ("SBUX", "스타벅스"),                  \# 28위, 0.84%  
    ("MDLZ", "몬델리즈"),                  \# 41위, 0.55%  
    ("MU", "마이크론"),                    \# 35위, 0.67%  
    ("AVGO", "브로드컴"),                  \# 5위, 4.00%  
    ("ADBE", "어도비"),                    \# 17위, 1.23%  
    ("TXN", "텍사스 인스트루먼트"),        \# 19위, 1.14%  
    ("AMD", "AMD"),                        \# 24위, 1.04%  
    ("AMAT", "어플라이드 머티리얼즈")     \# 29위, 0.83%  
\]

# **테이블 DDL**

CREATE TABLE economic\_and\_stock\_data (  
    "날짜" DATE PRIMARY KEY,  
    "10년 기대 인플레이션율" NUMERIC,  
    "장단기 금리차" NUMERIC,  
    "기준금리" NUMERIC,  
    "미시간대 소비자 심리지수" NUMERIC,  
    "실업률" NUMERIC,  
    "2년 만기 미국 국채 수익률" NUMERIC,  
    "10년 만기 미국 국채 수익률" NUMERIC,  
    "금융스트레스지수" NUMERIC,  
    "개인 소비 지출" NUMERIC,  
    "소비자 물가지수" NUMERIC,  
    "5년 변동금리 모기지" NUMERIC,  
    "미국 달러 환율" NUMERIC,  
    "통화 공급량 M2" NUMERIC,  
    "가계 부채 비율" NUMERIC,  
    "GDP 성장률" NUMERIC,  
    "나스닥 종합지수" NUMERIC,  
    "S\&P 500 지수" NUMERIC,  
    "금 가격" NUMERIC,  
    "달러 인덱스" NUMERIC,  
    "나스닥 100" NUMERIC,  
    "S\&P 500 ETF" NUMERIC,  
    "QQQ ETF" NUMERIC,  
    "러셀 2000 ETF" NUMERIC,  
    "다우 존스 ETF" NUMERIC,  
    "VIX 지수" NUMERIC,  
    "닛케이 225" NUMERIC,  
    "상해종합" NUMERIC,  
    "항셍" NUMERIC,  
    "영국 FTSE" NUMERIC,  
    "독일 DAX" NUMERIC,  
    "프랑스 CAC 40" NUMERIC,  
    "미국 전체 채권시장 ETF" NUMERIC,  
    "TIPS ETF" NUMERIC,  
    "투자등급 회사채 ETF" NUMERIC,  
    "달러/엔" NUMERIC,  
    "달러/위안" NUMERIC,  
    "미국 리츠 ETF" NUMERIC,  
    "애플" NUMERIC,  
    "마이크로소프트" NUMERIC,  
    "아마존" NUMERIC,  
    "구글 A" NUMERIC,  
    "구글 C" NUMERIC,  
    "메타" NUMERIC,  
    "테슬라" NUMERIC,  
    "엔비디아" NUMERIC,  
    "코스트코" NUMERIC,  
    "넷플릭스" NUMERIC,  
    "페이팔" NUMERIC,  
    "인텔" NUMERIC,  
    "시스코" NUMERIC,  
    "컴캐스트" NUMERIC,  
    "펩시코" NUMERIC,  
    "암젠" NUMERIC,  
    "허니웰 인터내셔널" NUMERIC,  
    "스타벅스" NUMERIC,  
    "몬델리즈" NUMERIC,  
    "마이크론" NUMERIC,  
    "브로드컴" NUMERIC,  
    "어도비" NUMERIC,  
    "텍사스 인스트루먼트" NUMERIC,  
    "AMD" NUMERIC,  
    "어플라이드 머티리얼즈" NUMERIC  
);

​

\-- 토큰 정보를 저장할 테이블 생성  
CREATE TABLE access\_tokens (  
  id SERIAL PRIMARY KEY,                \-- 자동 증가 기본 키  
  access\_token TEXT NOT NULL,           \-- 접근 토큰 문자열  
  created\_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT\_TIMESTAMP,  \-- 생성 시간  
  expiration\_time TIMESTAMP WITH TIME ZONE NOT NULL,  \-- 만료 시간  
  is\_active BOOLEAN DEFAULT TRUE        \-- 활성 상태 (선택사항)  
);

\-- 인덱스 생성 (성능 최적화)  
CREATE INDEX idx\_access\_tokens\_expiration ON access\_tokens(expiration\_time);  
CREATE INDEX idx\_access\_tokens\_created\_at ON access\_tokens(created\_at);

\-- 주석 추가  
COMMENT ON TABLE access\_tokens IS '한국투자증권 API 접근 토큰 정보';  
COMMENT ON COLUMN access\_tokens.access\_token IS 'API 접근을 위한 JWT 토큰';  
COMMENT ON COLUMN access\_tokens.created\_at IS '토큰 생성 시간';  
COMMENT ON COLUMN access\_tokens.expiration\_time IS '토큰 만료 시간';  
COMMENT ON COLUMN access\_tokens.is\_active IS '토큰 활성 상태';

​

\-- predicted\_stocks 테이블 생성 (공백과 특수문자 포함된 원래 컬럼명 사용)  
CREATE TABLE IF NOT EXISTS predicted\_stocks (  
    id SERIAL PRIMARY KEY,  
    "날짜" DATE NOT NULL,  
      
    \-- 주식 예측 값 (27개 주식) \- 원래 컬럼명 그대로 사용  
    "애플\_Predicted" NUMERIC,  
    "애플\_Actual" NUMERIC,  
    "마이크로소프트\_Predicted" NUMERIC,  
    "마이크로소프트\_Actual" NUMERIC,  
    "아마존\_Predicted" NUMERIC,  
    "아마존\_Actual" NUMERIC,  
    "구글 A\_Predicted" NUMERIC,  
    "구글 A\_Actual" NUMERIC,  
    "구글 C\_Predicted" NUMERIC,  
    "구글 C\_Actual" NUMERIC,  
    "메타\_Predicted" NUMERIC,  
    "메타\_Actual" NUMERIC,  
    "테슬라\_Predicted" NUMERIC,  
    "테슬라\_Actual" NUMERIC,  
    "엔비디아\_Predicted" NUMERIC,  
    "엔비디아\_Actual" NUMERIC,  
    "코스트코\_Predicted" NUMERIC,  
    "코스트코\_Actual" NUMERIC,  
    "넷플릭스\_Predicted" NUMERIC,  
    "넷플릭스\_Actual" NUMERIC,  
    "페이팔\_Predicted" NUMERIC,  
    "페이팔\_Actual" NUMERIC,  
    "인텔\_Predicted" NUMERIC,  
    "인텔\_Actual" NUMERIC,  
    "시스코\_Predicted" NUMERIC,  
    "시스코\_Actual" NUMERIC,  
    "컴캐스트\_Predicted" NUMERIC,  
    "컴캐스트\_Actual" NUMERIC,  
    "펩시코\_Predicted" NUMERIC,  
    "펩시코\_Actual" NUMERIC,  
    "암젠\_Predicted" NUMERIC,  
    "암젠\_Actual" NUMERIC,  
    "허니웰 인터내셔널\_Predicted" NUMERIC,  
    "허니웰 인터내셔널\_Actual" NUMERIC,  
    "스타벅스\_Predicted" NUMERIC,  
    "스타벅스\_Actual" NUMERIC,  
    "몬델리즈\_Predicted" NUMERIC,  
    "몬델리즈\_Actual" NUMERIC,  
    "마이크론\_Predicted" NUMERIC,  
    "마이크론\_Actual" NUMERIC,  
    "브로드컴\_Predicted" NUMERIC,  
    "브로드컴\_Actual" NUMERIC,  
    "어도비\_Predicted" NUMERIC,  
    "어도비\_Actual" NUMERIC,  
    "텍사스 인스트루먼트\_Predicted" NUMERIC,  
    "텍사스 인스트루먼트\_Actual" NUMERIC,  
    "AMD\_Predicted" NUMERIC,  
    "AMD\_Actual" NUMERIC,  
    "어플라이드 머티리얼즈\_Predicted" NUMERIC,  
    "어플라이드 머티리얼즈\_Actual" NUMERIC,  
    "S\&P 500 ETF\_Predicted" NUMERIC,  
    "S\&P 500 ETF\_Actual" NUMERIC,  
    "QQQ ETF\_Predicted" NUMERIC,  
    "QQQ ETF\_Actual" NUMERIC,  
      
    \-- 생성 시간 기록  
    created\_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),  
      
    \-- 날짜에 대한 인덱스 추가  
    CONSTRAINT unique\_prediction\_date UNIQUE ("날짜")  
);

\-- 날짜 검색을 위한 인덱스  
CREATE INDEX IF NOT EXISTS idx\_predicted\_stocks\_date ON predicted\_stocks ("날짜");

​

\-- stock\_analysis\_results 테이블 생성  
CREATE TABLE IF NOT EXISTS stock\_analysis\_results (  
    id SERIAL PRIMARY KEY,  
    "Stock" TEXT NOT NULL,  
    "MAE" NUMERIC,  
    "MSE" NUMERIC,  
    "RMSE" NUMERIC,  
    "MAPE (%)" NUMERIC,  
    "Accuracy (%)" NUMERIC,  
    "Last Actual Price" NUMERIC,  
    "Predicted Future Price" NUMERIC,  
    "Predicted Rise" BOOLEAN,  
    "Rise Probability (%)" NUMERIC,  
    "Recommendation" TEXT,  
    "Analysis" TEXT,  
      
    \-- 생성 시간 기록  
    created\_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()  
);

\-- 주식명 검색을 위한 인덱스  
CREATE INDEX IF NOT EXISTS idx\_stock\_analysis\_stock ON stock\_analysis\_results ("Stock");

\-- 추천 검색을 위한 인덱스  
CREATE INDEX IF NOT EXISTS idx\_stock\_analysis\_recommendation ON stock\_analysis\_results ("Recommendation");

\-- 상승확률 검색을 위한 인덱스  
CREATE INDEX IF NOT EXISTS idx\_stock\_analysis\_rise\_probability ON stock\_analysis\_results ("Rise Probability (%)");

​

CREATE TABLE ticker\_sentiment\_analysis (  
    id SERIAL PRIMARY KEY,  
    ticker VARCHAR(10) NOT NULL,  
    average\_sentiment\_score FLOAT NOT NULL,  
    article\_count INTEGER NOT NULL,  
    calculation\_date TIMESTAMP NOT NULL,  
    created\_at TIMESTAMP DEFAULT CURRENT\_TIMESTAMP  
);

​

CREATE TABLE stock\_recommendations (  
    "날짜" DATE,  
    "종목" VARCHAR(50),  
    "SMA20" NUMERIC,  
    "SMA50" NUMERIC,  
    "골든\_크로스" BOOLEAN,  
    "RSI" NUMERIC,  
    "MACD" NUMERIC,  
    "Signal" NUMERIC,  
    "MACD\_매수\_신호" BOOLEAN,  
    "추천\_여부" BOOLEAN,  
    PRIMARY KEY ("날짜", "종목")  
);

​

\-- stock\_daily\_volume 테이블 생성 (원래 컬럼명 그대로 사용)  
CREATE TABLE IF NOT EXISTS stock\_daily\_volume (  
    "날짜" DATE PRIMARY KEY,  
    "애플" BIGINT,  
    "마이크로소프트" BIGINT,  
    "아마존" BIGINT,  
    "구글 A" BIGINT,  
    "구글 C" BIGINT,  
    "메타" BIGINT,  
    "테슬라" BIGINT,  
    "엔비디아" BIGINT,  
    "코스트코" BIGINT,  
    "넷플릭스" BIGINT,  
    "페이팔" BIGINT,  
    "인텔" BIGINT,  
    "시스코" BIGINT,  
    "컴캐스트" BIGINT,  
    "펩시코" BIGINT,  
    "암젠" BIGINT,  
    "허니웰 인터내셔널" BIGINT,  
    "스타벅스" BIGINT,  
    "몬델리즈" BIGINT,  
    "마이크론" BIGINT,  
    "브로드컴" BIGINT,  
    "어도비" BIGINT,  
    "텍사스 인스트루먼트" BIGINT,  
    "AMD" BIGINT,  
    "어플라이드 머티리얼즈" BIGINT,  
    "S\&P 500 ETF" BIGINT,  
    "QQQ ETF" BIGINT

);

# **FastAPI**

## **1\. FastAPI란 무엇인가**

### **1.1 FastAPI 소개**

FastAPI는 Python으로 만들어진 고성능 웹 프레임워크다. 주로 **API**(Application Programming Interface, 프로그램 간 데이터를 주고받는 인터페이스)를 빠르고 쉽게 개발하는 데 사용한다. 특히 **비동기 처리**(여러 작업을 동시에 효율적으로 처리하는 기능)를 지원해 속도가 빠르다.

FastAPI는 Python 3.6 이상에서 동작하며, **비동기 웹 프레임워크**와 **데이터 검증 및 직렬화 도구**를 기반으로 한다. 이 조합 덕분에 성능과 사용 편의성을 모두 갖췄다.

추가 보강 설명:

다른 프레임워크들(예: Spring Boot, Node.js)도 비동기 처리를 지원하지만, FastAPI는 다음과 같은 차별화된 장점을 가진다:

* **Python의 타입 힌트와 Pydantic 통합**

   FastAPI는 Python의 타입 힌트를 활용하여, API의 입력 및 출력 데이터를 자동으로 검증하고 문서화한다. 이를 통해 잘못된 데이터 입력이나 오류를 초기에 잡아내고, 코드 가독성과 유지보수성을 높일 수 있다.

* **Starlette 기반 경량 서버**

   FastAPI는 내부적으로 Starlette라는 라이브러리를 사용한다.

   **Starlette란?**

  * Starlette는 비동기 기능을 제공하는 경량 웹 프레임워크로, 라우팅, 미들웨어, WebSocket 등 기본적인 웹 기능을 지원한다.  
  * 이를 통해 FastAPI는 복잡한 설정 없이도 높은 동시성(여러 요청을 동시에 처리)을 효율적으로 지원할 수 있다.  
* **동시성 지원의 효과**

  * **빠른 응답 시간:** 한 사용자의 요청을 처리하는 동안 다른 사용자의 요청도 동시에 처리할 수 있어, 응답 시간이 단축된다.  
  * **리소스 효율성:** 서버가 I/O 작업(예: 데이터베이스 호출, 외부 API 호출)을 기다리는 동안 다른 요청을 처리함으로써, 서버 자원을 보다 효율적으로 사용할 수 있다.  
  * **높은 확장성:** 많은 동시 접속자와 요청이 발생하는 환경에서도 안정적으로 서비스를 제공할 수 있다.  
* **개발자 경험 향상**

   자동 문서화(Swagger UI, ReDoc)와 내장 데이터 검증 기능 덕분에, 개발 단계부터 오류를 최소화하고 안정적인 API를 구축할 수 있다. 또한, Python의 직관적인 문법과 async/await 구문을 사용해 비동기 코드를 쉽게 작성할 수 있다.

이러한 점들로 FastAPI는 다른 비동기 프레임워크와 비교했을 때, 개발 속도와 유지보수 측면에서 강력한 경쟁력을 가진다.

### **1.2 FastAPI의 주요 특징과 장점**

* **빠른 속도**: 비동기 처리를 지원해 동시에 많은 요청을 처리한다. Node.js나 Go 같은 언어와 비슷한 성능을 낸다.

* **간단한 코드**: Python의 타입 힌트(예: name: str)를 사용해 코드가 간결하고 읽기 쉽다.

* **자동 문서화**: API를 만들면 **Swagger UI**와 **ReDoc**으로 자동 생성된 문서를 제공한다. 이를 통해 API를 바로 테스트해볼 수 있다.

  * **Swagger UI는 직접 API를 테스트할 수 있어 개발 중에 많이 씁니다.ReDoc은 보기 좋고 깔끔한 문서를 제공해서 외부 사람들에게 보여주기 좋습니다.**  
    * **Swagger UI**는 직접 API를 테스트할 수 있어 개발 중에 많이 씁니다.  
    * **ReDoc**은 보기 좋고 깔끔한 문서를 제공해서 외부 사람들에게 보여주기 좋습니다.  
* **데이터 검증**: Pydantic을 사용해 입력 데이터를 자동으로 검증하고, 오류가 있으면 친절한 메시지를 반환한다.

  * **Pydantic이란?**

     **사용자가 API에 잘못된 데이터를 입력했을 때 자동으로 이를 감지해 알려주는 도구입니다. 예를 들어, 주식 주문에서 주문 수량을 실수로 문자로 입력했을 때, 오류 메시지로 문제를 알려줍니다.**

     **이렇게 하면 데이터를 잘못 처리하거나 시스템이 오작동하는 일을 방지할 수 있습니다.**

* **비동기 지원**: I/O 작업(예: 외부 API 호출, 데이터베이스 쿼리)이 많은 프로젝트에서 효율적이다.

### **1.3 왜 FastAPI를 사용하나**

* **빠른 개발**: 복잡한 설정 없이 몇 줄로 API를 만들 수 있다.  
* **주식 자동매매에 적합**: 실시간 주식 데이터를 가져오거나 매매 주문을 처리할 때 비동기 기능이 빛을 발한다.  
* **유지보수 용이**: 코드가 모듈화되고 깔끔해 나중에 수정하거나 확장하기 쉽다.

**예시**: 주식 가격을 실시간으로 가져오는 API를 만들 때, FastAPI는 비동기 호출로 여러 주식의 데이터를 동시에 처리할 수 있다.

---

## **2\. FastAPI 기본 개념**

### **2.1 API가 무엇인가**

API는 프로그램들이 서로 데이터를 주고받을 수 있게 해주는 연결고리다. 예를 들어, 주식 자동매매 시스템에서 한국투자증권 API를 호출해 삼성전자 주식 가격을 가져오거나 매수 주문을 보낼 수 있다.

**비유**: API는 식당의 웨이터와 같다. 여러분(클라이언트)이 주문을 하면 웨이터(API)가 주방(서버)에 전달하고, 음식(데이터)을 가져다준다.

### **2.2 RESTful API란 무엇인가**

RESTful API는 HTTP 프로토콜을 기반으로 데이터를 주고받는 규칙이다. 주요 HTTP 메서드와 그 역할을 주식 자동매매에 맞춰 설명한다:

* **GET**: 데이터를 조회한다. (예: /stock/price로 삼성전자 주가 조회)  
* **POST**: 새 데이터를 생성한다. (예: /order로 매수 주문 생성)  
* **PUT**: 기존 데이터를 수정한다. (예: /order/123로 주문 수량 변경)  
* **DELETE**: 데이터를 삭제한다. (예: /order/123로 주문 취소)

**예시**:

GET /stock/KRX:005930 \-\> {"symbol": "KRX:005930", "price": 70000}  
POST /order \-\> {"symbol": "KRX:005930", "quantity": 10, "type": "buy"}

### **2.3 FastAPI는 어떻게 동작하나**

FastAPI는 \*\*경로(Path)\*\*와 \*\*경로 연산자(Path Operation)\*\*를 사용해 API를 정의한다.

* **경로**: URL의 주소다. (예: /stock/price)  
* **경로 연산자**: 해당 경로에서 실행할 작업(GET, POST 등)을 정의한 함수다.

**예시**:

@app.get("/stock/price")  
def get\_price():  
    return {"price": 70000}

위 코드는 /stock/price로 GET 요청이 오면 70000을 반환한다.

---

## **3\. FastAPI 설치와 준비**

### **3.1 Python 설치**

FastAPI는 Python 3.6 이상에서 동작한다. [**공식 사이트**](https://www.python.org/downloads/)에서 최신 버전을 설치한다.

**확인 방법**:

`python --version`

3.6 이상이 출력되면 준비가 된 것이다.

### **3.2 FastAPI와 Uvicorn 설치**

FastAPI와 이를 실행할 서버인 Uvicorn을 설치한다:

`pip install fastapi uvicorn`

* **FastAPI**: API를 만드는 핵심 도구다.  
* **Uvicorn**: FastAPI 앱을 실행하는 서버다.

**의존성 저장**:

`pip freeze > requirements.txt`

이 파일로 나중에 동일한 환경을 재현할 수 있다.

**Uvicorn**은 FastAPI 앱을 실행하는 ASGI(Asynchronous Server Gateway Interface) 서버로, FastAPI와 같은 비동기 프레임워크를 효과적으로 지원합니다.

반면에 **Spring Boot**에서는 주로 **Tomcat**과 같은 서블릿 컨테이너를 사용합니다. 두 서버의 차이는 다음과 같습니다:

* **비동기 처리 방식**  
  * **Uvicorn:** ASGI 서버로, 비동기 I/O를 기본적으로 지원합니다. 이를 통해 수많은 동시 요청을 효율적으로 처리하며, I/O 작업이 많은 환경(예: 데이터베이스 호출, 외부 API 호출)에 최적화되어 있습니다.  
  * **Tomcat:** 서블릿 컨테이너로, 전통적으로 동기 방식의 서블릿 기반 요청 처리를 합니다. 최근에는 비동기 서블릿 지원이 추가되었지만, 기본 아키텍처는 동기 처리에 가깝습니다.  
* **경량성과 성능**  
  * **Uvicorn:** 경량 서버로 빠른 시작 시간과 낮은 메모리 소비를 자랑합니다. 비동기 환경에서 높은 동시성을 요구하는 경우에도 효과적으로 동작합니다.  
  * **Tomcat:** 비교적 무겁고, 안정성과 확장성 측면에서는 오랜 기간 검증되어 왔으나, Uvicorn과 같이 경량화되어 있지는 않습니다.  
* **개발 환경과 생태계**  
  * **Uvicorn:** FastAPI와 함께 사용되며, Python의 async/await 구문과 자연스럽게 통합되어 개발자가 비동기 코드를 작성하고 관리하기에 용이합니다.  
  * **Tomcat:** Java 기반의 Spring Boot 애플리케이션과 함께 사용되며, 서블릿 API와 Java EE 생태계에 맞게 설계되어 있습니다.

요약하면, Uvicorn은 FastAPI의 비동기 특성을 최대한 활용하기 위해 최적화된 경량 서버이며, Tomcat은 전통적인 동기 방식의 웹 애플리케이션 실행 환경을 제공하는 서블릿 컨테이너입니다. 각 서버는 사용하는 언어와 프레임워크에 맞게 설계되어 있으며, 비동기 처리와 경량성 측면에서는 Uvicorn이, 안정성과 생태계 측면에서는 Tomcat이 강점을 보인다고 볼 수 있습니다.

---

## **4\. FastAPI로 첫 API 만들기**

### **4.1 "Hello, World\!" API**

간단한 API를 만들어 FastAPI의 기본 동작을 확인한다.

1. [main.py](http://main.py) 파일을 생성한다.  
2. 다음 코드를 입력한다:

from fastapi import FastAPI

app \= FastAPI()

@app.get("/")  
def read\_root():  
    return {"Hello": "World"}

* **줄별 설명**:  
  * from fastapi import FastAPI: FastAPI 클래스를 가져온다.  
  * app \= FastAPI(): FastAPI 애플리케이션 객체를 생성한다.  
  * @app.get("/"): 루트 경로(/)에 GET 요청을 처리한다.  
  * return {"Hello": "World"}: JSON 형식으로 응답을 반환한다.  
1. 터미널에서 실행한다:

    `uvicorn main:app --reload`

   * main:app: [main.py](http://main.py) 파일의 app 객체를 실행한다.  
   * \-reload: 코드 변경 시 자동으로 서버를 재시작한다.  
2. 브라우저에서 http://127.0.0.1:8000에 접속한다. 다음이 표시된다:

    `{"Hello": "World"}`

### **4.2 Swagger UI와 ReDoc 확인**

FastAPI는 자동으로 API 문서를 생성한다.

* **Swagger UI**: [http://127.0.0.1:8000/docs에서](http://127.0.0.1:8000/docs%EC%97%90%EC%84%9C) 확인한다. "Try it out" 버튼으로 API를 테스트할 수 있다.  
* **ReDoc**: [http://127.0.0.1:8000/redoc에서](http://127.0.0.1:8000/redoc%EC%97%90%EC%84%9C) 깔끔한 문서 형식을 제공한다.

**테스트 방법**:

1. /docs에 접속한다.  
2. GET / 엔드포인트를 펼친다.  
3. "Try it out" → "Execute"를 클릭한다. 동일한 {"Hello": "World"} 응답을 확인한다.

---

## **5\. FastAPI 프로젝트 구조와 파일 역할**

### **5.1 간단한 예시 프로젝트 구조**

`stock_trading/ ├── app/ │ ├── __init__.py │ ├── main.py │ ├── routers/ │ │ ├── __init__.py │ │ └── stock.py │ ├── schemas/ │ │ ├── __init__.py │ │ └── stock.py │ ├── services/ │ │ ├── __init__.py │ │ └── stock_service.py └── requirements.txt`

* [**main.py**](http://main.py): FastAPI 앱의 시작점이다.  
* **routers/**: API 경로를 기능별로 나눈다. (예: 주식, 주문)  
* **schemas/**: 데이터 형식을 정의한다. (Pydantic 사용)  
* **services/**: 비즈니스 로직(예: 외부 API 호출)을 처리한다.

### **5.2 init.py의 역할과 필요성**

* **역할**: 폴더를 Python 패키지로 만든다. 패키지는 여러 모듈을 묶어 관리하는 단위다.  
* **필요성**: routers 폴더에 **init**.py가 있어야 from app.routers.stock import router처럼 모듈을 가져올 수 있다. 없으면 Python이 폴더를 패키지로 인식하지 않는다.  
* **활용 예시**:이렇게 하면 main.py에서 깔끔하게 라우터를 등록할 수 있다.

### **5.3 \_\_pycache\_\_의 역할과 생성 이유**

* **역할**: Python이 코드를 컴파일한 바이트코드를 저장한다. 실행 속도를 높이는 캐시다.  
* **생성 이유**: main.py를 실행하면 Python이 이를 .pyc 파일로 변환해 \_\_pycache\_\_에 저장한다. 이후 실행 시 이 파일을 사용해 속도를 개선한다.  
* **예시**: [main.py](http://main.py) 실행 후 **pycache**/main.cpython-39.pyc가 생성된다.  
* **관리 필요성**: Python이 자동으로 관리하므로 신경 쓸 필요가 없다.

---

## **6\. 주식 자동매매 프로그램에 FastAPI 적용하기**

이 섹션에서는 FastAPI를 활용해 주식 자동매매 프로그램을 구현하는 방법을 실제 코드와 함께 자세히 설명한다. 여러분이 작성한 코드를 기반으로, 한국투자증권 API를 사용해 주식 데이터를 조회하고 매매를 실행하는 과정을 중심으로 다룬다. 또한, 코드에서 사용된 주요 기능(토큰 관리, 잔고 조회, 주문 실행 등)을 FastAPI와 통합하는 방법을 단계별로 설명한다.

---

### **6.1 주식 자동매매란 무엇인가**

주식 자동매매는 미리 정의한 규칙에 따라 주식을 자동으로 사고파는 시스템이다. 예를 들어, "주가가 5% 오르면 매도" 또는 "특정 조건이 충족되면 매수"와 같은 규칙을 코드로 구현한다. FastAPI는 이러한 시스템에서 데이터 수집, 분석, 매매 실행을 API로 처리할 수 있게 해준다. 여러분의 코드에서는 한국투자증권 API를 활용해 국내 및 해외 주식의 잔고 조회, 주문 실행, 예약 주문 등을 처리하고 있다.

---

### **6.2 실전 예제: 주식 잔고 조회 API**

여러분의 코드에서 한국투자증권 API를 사용해 국내 및 해외 주식 잔고를 조회하는 기능을 FastAPI로 구현해봅니다.

이 예제에서는 requests 라이브러리를 사용해 동기적으로 API를 호출하며, FastAPI를 통해 클라이언트가 잔고 정보를 요청할 수 있도록 한다.

### **6.2.1 의존성 확인**

여러분의 코드는 requests 라이브러리를 사용한다. 이미 설치되어 있어야 하며, 설치가 필요하다면 다음 명령어를 실행한다:

`pip install requests`

또한, supabase와 pytz 같은 라이브러리도 사용하므로 설치가 필요하다:

`pip install supabase pytz`

### **6.2.2 FastAPI 라우터 작성**

app/routers/stock.py에 잔고 조회 API를 추가한다. 여러분의 코드에서 get\_domestic\_balance와 get\_overseas\_balance 함수를 활용한다.

from fastapi import APIRouter, HTTPException  
from app.services.stock\_service import get\_domestic\_balance, get\_overseas\_balance  
import logging

\*\# 로깅 설정\*  
logging.basicConfig(level=logging.INFO)  
logger \= logging.getLogger(\_\_name\_\_)

router \= APIRouter()

@router.get("/balance/domestic")  
def get\_domestic\_balance\_endpoint():  
    """  
    국내 주식 잔고를 조회하는 API  
    """  
    try:  
        logger.info("국내 주식 잔고 조회 요청 시작")  
        result \= get\_domestic\_balance()  
          
        \*\# API 응답 검증\*  
        if result.get("rt\_cd") \!= "0":  
            logger.error(f"국내 주식 잔고 조회 실패: {result.get('msg1')}")  
            raise HTTPException(status\_code=400, detail=result.get("msg1", "국내 주식 잔고 조회 실패"))  
          
        logger.info("국내 주식 잔고 조회 성공")  
        return result  
    except Exception as e:  
        logger.error(f"국내 주식 잔고 조회 중 오류 발생: {str(e)}")  
        raise HTTPException(status\_code=500, detail=f"국내 주식 잔고 조회 중 오류 발생: {str(e)}")

@router.get("/balance/overseas")  
def get\_overseas\_balance\_endpoint():  
    """  
    해외 주식 잔고를 조회하는 API  
    """  
    try:  
        logger.info("해외 주식 잔고 조회 요청 시작")  
        result \= get\_overseas\_balance()  
          
        \*\# API 응답 검증\*  
        if result.get("rt\_cd") \!= "0":  
            logger.error(f"해외 주식 잔고 조회 실패: {result.get('msg1')}")  
            raise HTTPException(status\_code=400, detail=result.get("msg1", "해외 주식 잔고 조회 실패"))  
          
        logger.info("해외 주식 잔고 조회 성공")  
        return result  
    except Exception as e:  
        logger.error(f"해외 주식 잔고 조회 중 오류 발생: {str(e)}")  
        raise HTTPException(status\_code=500, detail=f"해외 주식 잔고 조회 중 오류 발생: {str(e)}")

### **6.2.3 FastAPI 메인 파일 수정**

app/main.py에 위 라우터를 등록한다:

from fastapi import FastAPI  
from app.routers import stock

app \= FastAPI()  
app.include\_router(stock.router, prefix="/api")

### **6.2.4 코드 설명**

* **라우터 설정**: APIRouter를 사용해 /balance/domestic과 /balance/overseas 경로를 정의한다.  
* **잔고 조회 함수 호출**: 여러분의 코드에서 정의한 get\_domestic\_balance와 get\_overseas\_balance를 호출한다. 이 함수들은 한국투자증권 API를 통해 잔고 정보를 가져온다.  
* **로깅**: 요청 시작과 성공/실패를 로깅해 디버깅에 활용한다.  
* **에러 처리**: API 응답의 rt\_cd가 "0"이 아니면 실패로 간주하고, HTTPException으로 클라이언트에 에러를 전달한다.

### **6.2.5 실행 및 테스트**

1. FastAPI 서버를 실행한다:

    `uvicorn app.main:app --reload`

2. 브라우저 또는 Postman으로 다음 URL에 접속한다:

   * 국내 잔고: [http://127.0.0.1:8000/api/balance/domestic](http://127.0.0.1:8000/api/balance/domestic)  
   * 해외 잔고: [http://127.0.0.1:8000/api/balance/overseas](http://127.0.0.1:8000/api/balance/overseas)

응답 예시:

 {  
    "rt\_cd": "0",  
    "msg\_cd": "MCA00000",  
    "msg1": "정상처리 되었습니다.",  
    "output1": \[  
        {  
            "ovrs\_pdno": "AAPL",  
            "pchs\_avg\_pric": "150.00",  
            "now\_pric2": "155.00",  
            "ord\_psbl\_qty": "10"  
        }  
    \]  
}

3. 

---

### **6.3 실전 예제: 해외 주식 주문 API**

여러분의 코드에서 order\_overseas\_stock 함수를 사용해 해외 주식을 매수/매도하는 API를 구현한다.

### **6.3.1 Pydantic 모델 정의**

먼저, 요청 데이터를 검증하기 위해 Pydantic 모델을 정의한다. app/schemas/stock.py에 추가한다:

from pydantic import BaseModel

class OverseasOrderRequest(BaseModel):  
    OVRS\_EXCG\_CD: str  \*\# 거래소 코드 (예: NASD, NYSE)\*  
    CANO: str | None \= None  \*\# 계좌번호\*  
    ACNT\_PRDT\_CD: str | None \= None  \*\# 계좌상품코드\*  
    PDNO: str  \*\# 종목코드 (예: AAPL)\*  
    ORD\_QTY: str  \*\# 주문수량\*  
    OVRS\_ORD\_UNPR: str  \*\# 주문단가\*  
    ORD\_SVR\_DVSN\_CD: str | None \= "0"  \*\# 주문서버구분코드\*  
    ORD\_DVSN: str | None \= "00"  \*\# 주문구분 (00: 지정가)\*  
    is\_buy: bool \= True  \*\# 매수/매도 여부\*

### **6.3.2 주문 API 구현**

app/routers/stock.py에 주문 API를 추가한다:

from fastapi import APIRouter, HTTPException  
from app.services.stock\_service import order\_overseas\_stock  
from app.schemas.stock import OverseasOrderRequest  
import logging

router \= APIRouter()

@router.post("/order/overseas")  
def order\_overseas\_stock\_endpoint(order: OverseasOrderRequest):  
    """  
    해외 주식을 매수/매도하는 API  
    """  
    try:  
        logger.info(f"해외 주식 주문 요청: {order.PDNO}, 매수여부: {order.is\_buy}")  
        result \= order\_overseas\_stock(order.dict())  
          
        if result.get("rt\_cd") \!= "0":  
            logger.error(f"해외 주식 주문 실패: {result.get('msg1')}")  
            raise HTTPException(status\_code=400, detail=result.get("msg1", "해외 주식 주문 실패"))  
          
        logger.info(f"해외 주식 주문 성공: {result}")  
        return result  
    except Exception as e:  
        logger.error(f"해외 주식 주문 중 오류 발생: {str(e)}")  
        raise HTTPException(status\_code=500, detail=f"해외 주식 주문 중 오류 발생: {str(e)}")

### **6.3.3 코드 설명**

* **Pydantic 모델**: OverseasOrderRequest를 사용해 요청 데이터를 검증한다. 필수 필드(예: OVRS\_EXCG\_CD, PDNO)를 정의하고, 선택 필드(예: CANO)는 기본값으로 설정한다.  
* **주문 실행**: order\_overseas\_stock 함수를 호출해 한국투자증권 API로 주문을 보낸다. 이 함수는 거래소 코드에 따라 적절한 tr\_id를 설정하고, 매수/매도 여부를 처리한다.  
* **에러 처리**: API 응답의 rt\_cd가 "0"이 아니면 실패로 간주하고, 클라이언트에 에러를 전달한다.

### **6.3.4 테스트**

1. Swagger UI([http://127.0.0.1:8000/docs](http://127.0.0.1:8000/docs))에서 /order/overseas 엔드포인트를 테스트한다.

요청 예시:

 {  
    "OVRS\_EXCG\_CD": "NASD",  
    "PDNO": "AAPL",  
    "ORD\_QTY": "10",  
    "OVRS\_ORD\_UNPR": "155.00",  
    "is\_buy": true  
}

2. 

응답 예시:

 {  
    "rt\_cd": "0",  
    "msg\_cd": "MCA00000",  
    "msg1": "정상처리 되었습니다.",  
    "output": {  
        "KRX\_FWDG\_ORD\_ORGNO": "00000",  
        "ODNO": "123456",  
        "ORD\_TMD": "20250322153000"  
    }  
}

3. 

---

### **6.4 실전 예제: 현재 체결가 조회 및 자동 매매 로직**

여러분의 코드에서 get\_current\_price 함수를 사용해 주식의 현재 체결가를 조회하고, 이를 기반으로 자동 매매 로직을 구현한다.

### **6.4.1 현재 체결가 조회 API**

app/routers/stock.py에 추가한다:

@router.get("/stock/price/{symbol}")  
def get\_current\_price\_endpoint(symbol: str, exchange: str \= "NASD"):  
    """  
    해외 주식의 현재 체결가를 조회하는 API  
    """  
    try:  
        logger.info(f"현재 체결가 조회 요청: {symbol}, 거래소: {exchange}")  
        params \= {  
            "AUTH": "",  
            "EXCD": exchange,  
            "SYMB": symbol  
        }  
        result \= get\_current\_price(params)  
          
        if result.get("rt\_cd") \!= "0":  
            logger.error(f"현재 체결가 조회 실패: {result.get('msg1')}")  
            raise HTTPException(status\_code=400, detail=result.get("msg1", "현재 체결가 조회 실패"))  
          
        logger.info(f"현재 체결가 조회 성공: {result}")  
        return result  
    except Exception as e:  
        logger.error(f"현재 체결가 조회 중 오류 발생: {str(e)}")  
        raise HTTPException(status\_code=500, detail=f"현재 체결가 조회 중 오류 발생: {str(e)}")

### **6.4.2 자동 매매 로직**

주가가 기준 가격 대비 5% 오르면 매도하는 로직을 구현한다:

@router.get("/stock/monitor/{symbol}")  
def monitor\_stock(symbol: str, exchange: str \= "NASD", base\_price: float \= 150.00):  
    """  
    주식 가격을 모니터링하고 자동 매매 조건에 따라 매수/매도 여부를 결정하는 API  
    """  
    try:  
        logger.info(f"주식 모니터링 시작: {symbol}, 기준 가격: {base\_price}")  
          
        \*\# 현재 체결가 조회\*  
        params \= {  
            "AUTH": "",  
            "EXCD": exchange,  
            "SYMB": symbol  
        }  
        price\_data \= get\_current\_price(params)  
          
        if price\_data.get("rt\_cd") \!= "0":  
            logger.error(f"현재 체결가 조회 실패: {price\_data.get('msg1')}")  
            raise HTTPException(status\_code=400, detail=price\_data.get("msg1", "현재 체결가 조회 실패"))  
          
        current\_price \= float(price\_data\["output"\]\["last"\])  
        logger.info(f"현재 가격: {current\_price}")  
          
        \*\# 매매 조건 확인\*  
        if current\_price \>= base\_price \* 1.05:  
            logger.info(f"{symbol} 5% 상승 감지, 매도 실행")  
              
            \*\# 매도 주문 실행\*  
            order\_data \= {  
                "OVRS\_EXCG\_CD": exchange,  
                "PDNO": symbol,  
                "ORD\_QTY": "10",  
                "OVRS\_ORD\_UNPR": str(current\_price),  
                "is\_buy": False  
            }  
            order\_result \= order\_overseas\_stock(order\_data)  
              
            if order\_result.get("rt\_cd") \!= "0":  
                logger.error(f"매도 주문 실패: {order\_result.get('msg1')}")  
                raise HTTPException(status\_code=400, detail=order\_result.get("msg1", "매도 주문 실패"))  
              
            return {"action": "sell", "price": current\_price, "order": order\_result}  
        else:  
            logger.info(f"{symbol} 조건 미충족, 보유 유지")  
            return {"action": "hold", "price": current\_price}  
    except Exception as e:  
        logger.error(f"주식 모니터링 중 오류 발생: {str(e)}")  
        raise HTTPException(status\_code=500, detail=f"주식 모니터링 중 오류 발생: {str(e)}")

### **6.4.3 코드 설명**

* **현재 체결가 조회**: get\_current\_price 함수를 호출해 주식의 현재 가격을 가져온다. params에 거래소 코드(EXCD)와 종목 코드(SYMB)를 전달한다.  
* **자동 매매 로직**: 현재 가격이 기준 가격의 105% 이상이면 매도 주문을 실행한다. order\_overseas\_stock 함수를 호출해 매도 주문을 처리한다.  
* **로깅과 에러 처리**: 각 단계에서 로깅을 통해 진행 상황을 추적하고, 에러 발생 시 클라이언트에 적절한 메시지를 전달한다.

### **6.4.4 테스트**

1. Swagger UI에서 /stock/monitor/{symbol} 엔드포인트를 테스트한다.  
2. 요청 예시:  
   * URL: [http://127.0.0.1:8000/api/stock/monitor/AAPL?exchange=NASD\&base\_price=150.00](http://127.0.0.1:8000/api/stock/monitor/AAPL?exchange=NASD&base_price=150.00)  
3. 응답 예시:

조건 충족 시:

 {  
    "action": "sell",  
    "price": 157.50,  
    "order": {  
        "rt\_cd": "0",  
        "msg\_cd": "MCA00000",  
        "msg1": "정상처리 되었습니다.",  
        "output": {  
            "KRX\_FWDG\_ORD\_ORGNO": "00000",  
            "ODNO": "123456",  
            "ORD\_TMD": "20250322153000"  
        }  
    }  
}

* 

조건 미충족 시:

 {  
    "action": "hold",  
    "price": 152.00  
}

* 

---

### **6.5 실제 적용 흐름**

여러분의 코드와 FastAPI를 통합한 전체 흐름을 정리한다:

1. **데이터 수집**:  
   * get\_current\_price를 사용해 주식의 현재 체결가를 조회한다.  
   * get\_domestic\_balance와 get\_overseas\_balance로 보유 주식 잔고를 확인한다.  
2. **분석**:  
   * 주식 가격 변동을 분석해 매매 조건(예: 5% 상승 시 매도)을 확인한다.  
   * monitor\_stock 엔드포인트에서 이 로직을 구현한다.  
3. **매매 실행**:  
   * 조건이 충족되면 order\_overseas\_stock를 호출해 매수/매도 주문을 실행한다.  
   * overseas\_order\_resv를 사용해 예약 주문을 설정할 수도 있다.

---

### **6.6 추가 기능: 토큰 관리와 동시성 처리**

여러분의 코드에서 get\_access\_token과 refresh\_token\_with\_retry 함수는 한국투자증권 API의 토큰을 관리한다. FastAPI에서 이를 활용할 때 주의할 점을 설명한다.

### **6.6.1 토큰 캐싱과 동시성**

* **토큰 캐싱**: \_token\_cache를 사용해 메모리에 토큰을 저장한다. 유효 기간 동안 재사용해 API 호출을 줄인다.  
* **동시성 처리**: threading.Lock을 사용해 토큰 갱신 시 동시 접근을 방지한다. FastAPI는 비동기 프레임워크지만, 여러분의 코드는 동기적으로 동작하므로 스레드 안전성을 보장해야 한다.

### **6.6.2 FastAPI와 통합**

FastAPI에서 비동기 처리를 위해 get\_access\_token을 비동기 함수로 변환할 수 있다. 하지만 현재 코드는 동기적으로 동작하므로, FastAPI의 동기 엔드포인트(def)를 사용해 문제없이 통합된다.

---

### **6.7 추가 팁**

* **비동기 전환 고려**: requests 대신 httpx를 사용하고, async def로 엔드포인트를 정의할 수 있다.  
* **API 호출 제한 관리**: 한국투자증권 API는 access\_token 호출 제한이 있으므로, 토큰 관리를 위한 별도 토큰 보관 로직 (본 강의에서 사용하는 함수: get\_access\_token)을 사용한다.  
* **로깅 활용**: 모든 API 호출과 응답을 로깅해 디버깅을 쉽게 한다.

---

## **7\. FastAPI와 Spring Boot 비교분석**

FastAPI와 Spring Boot는 모두 API 개발에 사용되지만 차이점이 뚜렷하다.

| 항목 | FastAPI | Spring Boot |
| ----- | ----- | ----- |
| **언어** | Python | Java |
| **성능** | 비동기 처리로 매우 빠르다 | 높은 성능을 내지만 설정이 필요하다 |
| **학습 난이도** | Python 기반으로 쉽고 직관적이다 | Java와 스프링 지식이 필요해 어렵다 |
| **문서화** | 자동 생성(Swagger UI, ReDoc)이 뛰어나다 | 별도 설정(Swagger 등)이 필요하다 |
| **생태계** | 성장 중이며 Python 커뮤니티가 강하다 | 성숙하고 방대한 라이브러리를 제공한다 |
| **적합한 용도** | 빠른 API 개발, 실시간 시스템에 강하다 | 복잡한 엔터프라이즈 애플리케이션에 적합하다 |

**주식 자동매매에서**:

* FastAPI는 실시간 데이터 처리와 빠른 개발이 필요한 경우 적합하다.  
* Spring Boot는 대규모 시스템이나 복잡한 비즈니스 로직을 다룰 때 유리하다.

---

## **8\. 추가 자료**

* [**FastAPI 공식 문서**](https://fastapi.tiangolo.com/)  
* [**Python 공식 문서**](https://docs.python.org/3/)  
* [**Pydantic 문서**](https://pydantic-docs.helpmanual.io/)

# **Alpha Vantage**

* 감정 점수(sentiment score)로, \-1에서 1 사이의 값을 가집니다.  
* 점수 범위에 따라 5가지 감정 레이블로 분류됩니다:  
  1. **Bearish (매도적)**: x ≤ \-0.35  
  2. **Somewhat Bearish (약간 매도적)**: \-0.35 \< x ≤ \-0.15  
  3. **Neutral (중립)**: \-0.15 \< x \< 0.15  
  4. **Somewhat Bullish (약간 매수적)**: 0.15 ≤ x \< 0.35  
  5. **Bullish (매수적)**: x ≥ 0.35

### **각 레이블의 의미**

* **Bearish (매도적)**: 뉴스 기사의 내용이 해당 종목(예: 테슬라, TSLA)에 대해 매우 부정적임을 나타냅니다. 주가 하락 가능성을 암시할 수 있음.  
  * 예: "테슬라, 중국 시장에서 판매 급감으로 주가 10% 하락 전망."  
* **Somewhat Bearish (약간 매도적)**: 부정적인 내용이 포함되어 있지만, 강한 매도 신호까지는 아님.  
  * 예: "테슬라, EV 시장 둔화로 성장 우려 제기."  
* **Neutral (중립)**: 기사가 종목에 대해 긍정적이지도, 부정적이지도 않음.  
  * 예: "테슬라, 새로운 공장 설립 계획 발표."  
* **Somewhat Bullish (약간 매수적)**: 긍정적인 내용이 포함되어 있지만, 강한 매수 신호까지는 아님.  
  * 예: "테슬라, 신제품 발표로 시장 기대감 상승."  
* **Bullish (매수적)**: 매우 긍정적인 내용으로, 주가 상승 가능성을 암시할 수 있음.  
  * 예: "테슬라, 예상보다 높은 실적으로 주가 급등."

### **감정 점수의 활용**

* Alpha Vantage는 각 뉴스 기사에 대해 overall\_sentiment\_score를 계산하고, 이 점수를 sentiment\_score\_definition 기준에 따라 레이블로 변환합니다.  
* 이를 통해 사용자는 기사의 감정傾向(주가에 미치는 긍정/부정 영향)을 직관적으로 파악할 수 있습니다.

### **점수 기준 상세**

Alpha Vantage는 점수 범위를 다음과 같이 세분화하여 감정 레이블을 정의합니다:

1. **x ≤ \-0.35 (Bearish)**  
   * 매우 부정적인 감정.  
   * 주가에 상당한 하락 압력을 가할 수 있는 뉴스(예: 대규모 리콜, 법적 문제, 실적 악화).  
   * 예: overall\_sentiment\_score: \-0.45 → "테슬라, 배터리 결함으로 대규모 리콜 발표."  
2. **\-0.35 \< x ≤ \-0.15 (Somewhat Bearish)**  
   * 약간 부정적인 감정.  
   * 주가에 하락 압력이 있지만, 강한 매도 신호는 아님(예: 경쟁 심화, 소폭 실적 하락).  
   * 예: overall\_sentiment\_score: \-0.20 → "테슬라, EV 시장 경쟁 심화로 성장 우려."  
3. **\-0.15 \< x \< 0.15 (Neutral)**  
   * 중립적인 감정.  
   * 주가에 큰 영향을 미치지 않을 가능성(예: 중립적 발표, 일반적인 기업 활동).  
   * 예: overall\_sentiment\_score: 0.05 → "테슬라, 새로운 공장 설립 계획."  
4. **0.15 ≤ x \< 0.35 (Somewhat Bullish)**  
   * 약간 긍정적인 감정.  
   * 주가 상승 가능성이 있지만, 강한 매수 신호는 아님(예: 긍정적인 소식, 소폭 실적 개선).  
   * 예: overall\_sentiment\_score: 0.25 → "테슬라, 신제품 발표로 시장 기대감 상승."  
5. **x ≥ 0.35 (Bullish)**  
   * 매우 긍정적인 감정.  
   * 주가 상승 가능성이 높음(예: 예상 초과 실적, 대규모 계약 체결).  
   * 예: overall\_sentiment\_score: 0.40 → "테슬라, Q1 실적 예상 상회로 주가 급등."

### **점수 계산 방식**

* **Alpha Vantage는 뉴스 기사의 텍스트를 자연어 처리(NLP) 기술로 분석하여 감정 점수를 계산합니다.**  
* **분석 요소**:  
  * **단어 및 문장 감정**: 긍정적 단어(예: "성장", "상승")와 부정적 단어(예: "하락", "위기")의 빈도와 강도.  
  * **문맥**: 종목과 관련된 문맥에서 단어의 의미를 해석(예: "테슬라 하락"은 부정적, "테슬라 비용 하락"은 긍정적일 수 있음).  
  * **감정 강도**: 단순 빈도가 아니라 감정의 강도를 반영(예: "급등"은 "상승"보다 더 긍정적).  
* **알고리즘**: 정확한 계산 방식은 공개되지 않았으나, 일반적으로 딥러닝 기반의 감정 분석 모델(예: BERT)을 사용하여 텍스트의 감정 점수를 추출합니다. Alpha Vantage는 금융 뉴스에 특화된 모델을 사용

### **수치의 신뢰도**

* Alpha Vantage는 주요 뉴스 출처(예: Reuters, CNBC)에서 데이터를 수집하므로 신뢰도가 높습니다.

# **Alpha Vantage API**

### **테이블 이름: ticker\_sentiment\_analysis**

### **컬럼:**

* id: 자동 생성되는 고유 ID (기본 키).  
* ticker: 티커 심볼 (문자열, 예: "TSLA").  
* average\_sentiment\_score: 필터링된 기사들의 ticker\_sentiment\_score 평균 (부동소수점).  
* article\_count: 평균 계산에 사용된 기사 수 (정수).  
* calculation\_date: 데이터 계산 날짜 (타임스탬프).  
* created\_at: 레코드 생성 시각 (타임스탬프, 기본값은 현재 시간).

### **DDL 스크립트:**

CREATE TABLE ticker\_sentiment\_analysis (  
    id SERIAL PRIMARY KEY,  
    ticker VARCHAR(10) NOT NULL,  
    average\_sentiment\_score FLOAT NOT NULL,  
    article\_count INTEGER NOT NULL,  
    calculation\_date TIMESTAMP NOT NULL,  
    created\_at TIMESTAMP DEFAULT CURRENT\_TIMESTAMP  
);

이 DDL은 Supabase에서 바로 실행 가능하며, 모든 티커 데이터를 단일 테이블에 저장할 수 있도록 설계되었습니다.

### **설명:**

1. **필터링**: relevance\_score가 0.2 이상이고 티커가 "TSLA"인 데이터만 추출.  
2. **평균 계산**: 추출된 ticker\_sentiment\_score의 평균을 계산.  
3. **저장**: 결과를 ticker\_sentiment\_analysis 테이블에 삽입.

## **24개 티커에 대한 확장 로직**

이제 24개 티커에 대해 API를 호출하고, 동일한 로직을 적용하는 함수를 작성합니다.

### **Python 코드:**

import requests  
import time  
from datetime import datetime  
from app.db.supabase import supabase

def fetch\_and\_store\_sentiment\_for\_tickers(tickers, api\_key, relevance\_threshold=0.2, sleep\_interval=15):  
    """  
    주어진 티커 목록에 대해 Alpha Vantage API를 호출하여 뉴스 감정 데이터를 가져오고,  
    relevance\_score가 threshold 이상인 기사들의 ticker\_sentiment\_score 평균을 계산하여  
    Supabase에 저장합니다.  
      
    Args:  
        tickers (list): 처리할 티커 목록  
        api\_key (str): Alpha Vantage API 키  
        relevance\_threshold (float): 관련성 점수 임계값 (기본값: 0.2)  
        sleep\_interval (int): API 호출 간격(초, 기본값: 15\)  
      
    Returns:  
        dict: 처리 결과 요약  
    """  
    base\_url \= "\<https://www.alphavantage.co/query\>"  
    params \= {  
        "function": "NEWS\_SENTIMENT",  
        "time\_from": "20250313T0000",  
        "limit": 100,  
        "apikey": api\_key  
    }  
      
    results \= \[\]  
      
    for ticker in tickers:  
        print(f"{ticker} 처리 중...")  
        params\["tickers"\] \= ticker  
          
        \*\# API 호출\*  
        response \= requests.get(base\_url, params=params)  
        if response.status\_code \!= 200:  
            results.append({"ticker": ticker, "message": "API 호출 실패", "status": "error"})  
            time.sleep(sleep\_interval)  
            continue  
          
        api\_data \= response.json()  
        feed \= api\_data.get('feed', \[\])  
          
        \*\# 티커 관련 기사 필터링\*  
        articles \= \[\]  
        for article in feed:  
            for sentiment in article.get('ticker\_sentiment', \[\]):  
                if (sentiment\['ticker'\] \== ticker and   
                    float(sentiment\['relevance\_score'\]) \>= relevance\_threshold):  
                    articles.append(float(sentiment\['ticker\_sentiment\_score'\]))  
          
        if not articles:  
            results.append({"ticker": ticker, "message": "관련 기사 없음", "status": "skipped"})  
            time.sleep(sleep\_interval)  
            continue  
          
        \*\# 평균 계산\*  
        average\_sentiment \= sum(articles) / len(articles)  
        article\_count \= len(articles)  
        calculation\_date \= datetime.now().strftime("%Y-%m-%d %H:%M:%S")  
          
        \*\# Supabase에 저장할 데이터\*  
        data \= {  
            "ticker": ticker,  
            "average\_sentiment\_score": average\_sentiment,  
            "article\_count": article\_count,  
            "calculation\_date": calculation\_date  
        }  
          
        \*\# Supabase에 삽입\*  
        supabase\_response \= supabase.table("ticker\_sentiment\_analysis").insert(data).execute()  
          
        if supabase\_response.data:  
            results.append({"ticker": ticker, "message": "데이터 저장 성공", "status": "success", "data": data})  
        else:  
            results.append({"ticker": ticker, "message": "데이터 저장 실패", "status": "error", "error": supabase\_response.error})  
          
        \*\# API 호출 간격\*  
        time.sleep(sleep\_interval)  
      
    return {"results": results}

\*\# 사용 예시\*  
tickers \= \[  
    "AAPL", "MSFT", "AMZN", "GOOGL", "GOOG", "META", "TSLA", "NVDA", "COST", "NFLX",  
    "PYPL", "INTC", "CSCO", "PEP", "AMGN", "HON", "SBUX", "MDLZ", "MU", "AVGO",  
    "ADBE", "TXN", "AMD", "AMAT"  
\]  
api\_key \= "api\_key"  
result \= fetch\_and\_store\_sentiment\_for\_tickers(tickers, api\_key)  
for res in result\["results"\]:  
    print(res)

### **설명:**

1. **티커 순회**: 24개 티커를 하나씩 처리.  
2. **API 호출**: 각 티커에 대해 Alpha Vantage API를 호출.  
3. **필터링 및 계산**: relevance\_score가 0.2 이상인 기사만 사용해 평균을 계산.  
4. **저장**: 결과를 Supabase에 삽입.  
5. **호출 간격**: 15초 대기하여 API 제한을 준수.

# **기술적 지표**

economic\_and\_stock\_data 테이블을 기반으로 주가 데이터를 활용하여 요청된 기술적 지표(골든 크로스, RSI, 거래량, ATR, MACD)를 계산할 수 있는지 검토하고, 가능하다면 API와 서비스 로직을 제공하며, 결과를 저장하기 위한 테이블 DDL도 제안하겠습니다. 아래에서 단계별로 분석하고 구현하겠습니다.

---

### **데이터 분석 및 지표 계산 가능성 검토**

economic\_and\_stock\_data 테이블에는 다음과 같은 데이터가 포함되어 있습니다:

* **날짜** ("날짜"): 각 행의 날짜 (기본 키).  
* **경제 지표**: "10년 기대 인플레이션율"부터 "미국 리츠 ETF"까지 (총 38개 컬럼).  
* **주식 종가**: "애플"부터 "어플라이드 머티리얼즈"까지 (총 25개 컬럼, 개별 주식의 종가 데이터).

이 테이블은 날짜별로 개별 주식의 종가 데이터를 제공하며, 시간순으로 정렬된 주가 정보를 포함합니다. 이제 각 기술적 지표를 계산할 수 있는지 확인해 보겠습니다.

### **1\. 골든 크로스 (Golden Cross)**

* **요구사항**: 단기 이동평균선 (20일 SMA) \> 장기 이동평균선 (50일 SMA).  
* **필요 데이터**: 주식의 일별 종가 데이터.  
* **분석**: 테이블에는 "애플", "마이크로소프트" 등의 종가가 날짜별로 제공됩니다. 20일 SMA는 최근 20일 종가의 평균, 50일 SMA는 최근 50일 종가의 평균으로 계산 가능합니다.  
* **결론**: **계산 가능**. 종가 데이터만으로 SMA를 계산하고 비교할 수 있습니다.

### **2\. RSI (Relative Strength Index)**

* **요구사항**: RSI \< 70 (과매수 상태가 아님 확인).  
* **필요 데이터**: 주식의 일별 종가 데이터 (14일 기간 기준으로 계산이 일반적).  
* **분석**: RSI는 종가의 변동(상승/하락)을 통해 평균 상승폭과 평균 하락폭을 계산한 후 공식(100 \- (100 / (1 \+ RS)))을 적용합니다. 테이블의 종가 데이터로 가격 변동을 계산할 수 있습니다.  
* **결론**: **계산 가능**. 종가 데이터만으로 RSI를 구할 수 있습니다.

### **3\. MACD (Moving Average Convergence Divergence)**

* **요구사항**: MACD 라인이 Signal 라인을 상향 돌파 시 매수 신호.  
* **필요 데이터**: 주식의 일별 종가 데이터 (12일 EMA, 26일 EMA, 9일 Signal EMA 계산).  
* **분석**: MACD는 12일 EMA와 26일 EMA의 차이로 계산되며, Signal 라인은 MACD의 9일 EMA입니다. 종가 데이터만 있으면 EMA를 계산할 수 있습니다.  
* **결론**: **계산 가능**. 종가 데이터로 MACD와 Signal 라인을 구할 수 있습니다.

### **종합 결론**

* **계산 가능한 지표**: 골든 크로스, RSI, MACD (종가 데이터만 필요).  
* **계산 불가능한 지표**: 거래량, ATR (거래량, 고가, 저가 데이터 필요).  
* 따라서, 현재 테이블 데이터를 기반으로 골든 크로스, RSI, MACD를 계산하여 주식 추천 로직을 구현할 수 있으며, 거래량과 ATR은 제외해야 합니다.

### **추천 조건**

* 골든 크로스: 20일 SMA \> 50일 SMA.  
* RSI \< 50\.  
* MACD: MACD \> Signal.  
* **추천 여부**: 위 3가지 조건이 모두 참일 때 추천.

### **테이블 DDL (저장용)**

계산된 지표와 추천 결과를 저장하기 위해 새 테이블을 생성합니다.

CREATE TABLE stock\_recommendations (  
    "날짜" DATE,  
    "종목" VARCHAR(50),  
    "골든\_크로스" BOOLEAN,  
    "RSI" NUMERIC,  
    "MACD\_매수\_신호" BOOLEAN,  
    "추천\_여부" BOOLEAN,  
    PRIMARY KEY ("날짜", "종목")  
);

### **1\. 골든 크로스 (Golden Cross): 20일 SMA \> 50일 SMA**

### **기본 이해**

* **정의**: 골든 크로스는 단기 이동평균선(SMA, Simple Moving Average)이 장기 이동평균선을 상향 돌파하는 상황을 의미합니다. 여기서는 20일 SMA(단기)가 50일 SMA(장기)를 초과할 때 발생합니다.  
* **계산**:  
  * 20일 SMA \= 최근 20일 종가의 평균.  
  * 50일 SMA \= 최근 50일 종가의 평균.  
  * 골든\_크로스 \= True if 20일 SMA \> 50일 SMA, else False.  
* **의미**: 주가가 상승 추세로 전환했거나 상승 모멘텀이 강화되고 있음을 나타냅니다.

### **해석**

* **매수 신호**: 골든 크로스는 일반적으로 강력한 매수 신호로 간주됩니다. 단기 평균이 장기 평균을 돌파하면 시장 참여자들이 주식을 적극적으로 매수하고 있으며, 상승장이 시작될 가능성이 높다고 봅니다.  
* **주의점**:  
  * 골든 크로스는 후행 지표(Lagging Indicator)로, 이미 상승이 시작된 후에 신호가 나타날 수 있습니다.  
  * 단기적인 변동성이나 거짓 돌파(False Breakout)에 주의해야 합니다.  
* **반대 신호**: 20일 SMA가 50일 SMA 아래로 하락하면 "데드 크로스(Death Cross)"로, 매도 신호로 해석됩니다.

### **장단점**

* **장점**: 장기 추세 전환을 포착하는 데 유용하며, 단순하고 직관적입니다.  
* **단점**: 단기적인 시장 소음(Noise)에 민감하지 않아 타이밍이 늦을 수 있습니다.

---

### **2\. RSI (상대강도지수, Relative Strength Index): RSI \< 50**

### **기본 이해**

* **정의**: RSI는 주식 가격의 상승과 하락 강도를 측정하여 과매수(Overbought)와 과매도(Oversold) 상태를 판단하는 모멘텀 지표입니다. 0에서 100 사이의 값을 가집니다.  
* **계산**:  
  * 최근 14일(기본 설정)의 가격 변동을 사용.  
  * 상승폭 평균(U)과 하락폭 평균(D)을 계산: RS \= U / D.  
  * RSI \= 100 \- (100 / (1 \+ RS)).  
* **조건**: 여기서는 RSI \< 50으로 설정되어 중립 구간 하단 이하를 의미합니다.

### **해석**

* **RSI \> 70**: 과매수 상태로, 주가가 과도하게 상승하여 조정(하락)이 임박했다고 봅니다.  
* **RSI \< 30**: 과매도 상태로, 주가가 과도하게 하락하여 반등(상승)이 가능성이 높다고 봅니다.  
* **RSI 30\~70**: 중립 구간으로, 강한 매수/매도 신호가 없음.  
* **RSI \< 50**: 중립 구간 하단으로, 하락 모멘텀이 약화되고 상승 가능성이 커질 수 있는 상태를 나타냅니다.  
* **매수 신호**: RSI \< 50은 과매도에 가까운 상태를 포함하며, 주가가 반등할 가능성을 시사합니다. 특히 RSI가 30 근처에서 50으로 회복될 때 강한 매수 신호로 해석될 수 있습니다.  
* **주의점**: RSI \< 50은 단독으로 강한 매수 신호가 되지 않을 수 있으며, 다른 지표와 결합하여 확인해야 합니다.

### **장단점**

* **장점**: 가격 모멘텀의 변화를 빠르게 포착하며, 과매수/과매도 상태를 직관적으로 보여줍니다.  
* **단점**: 단기적인 가격 변동에 민감하여 거짓 신호(False Signal)가 발생할 수 있습니다.

---

### **3\. MACD (이동평균 수렴-발산, Moving Average Convergence Divergence): MACD \> Signal**

### **기본 이해**

* **정의**: MACD는 단기와 장기 이동평균의 차이를 통해 주가의 모멘텀과 추세를 분석하는 지표입니다. 여기서는 MACD가 Signal(신호선)을 초과할 때 매수 신호로 사용됩니다.  
* **계산**:  
  * MACD \= 12일 EMA(지수 이동평균) \- 26일 EMA.  
  * Signal \= MACD의 9일 EMA.  
  * MACD\_매수\_신호 \= True if MACD \> Signal, else False.  
* **의미**: MACD가 Signal을 상향 돌파하면 단기 모멘텀이 장기 모멘텀을 초과하여 상승 추세가 강화되고 있음을 나타냅니다.

### **해석**

* **매수 신호**: MACD \> Signal은 주가가 상승 모멘텀을 얻고 있으며, 매수 타이밍으로 간주됩니다. 특히 MACD가 0선을 돌파하며 Signal을 초과하면 강한 상승 신호로 봅니다.  
* **매도 신호**: MACD \< Signal은 하락 모멘텀이 시작되었음을 나타내며, 매도 신호로 해석됩니다.  
* **주의점**:  
  * MACD는 추세와 모멘텀을 결합한 지표지만, 역시 후행성이 있어 단기 변동에는 둔감할 수 있습니다.  
  * 횡보 장세에서는 신호가 빈번히 바뀌며 신뢰도가 떨어질 수 있습니다.

### **장단점**

* **장점**: 추세와 모멘텀을 동시에 반영하여 신호의 신뢰도를 높일 수 있습니다.  
* **단점**: 단기적인 가격 변동에 비해 반응이 느릴 수 있으며, 횡보 장세에서 혼란을 줄 수 있습니다.

---

### **추천 여부: 3가지 조건의 결합**

### **조건**

* **골든\_크로스 \= True**: 20일 SMA \> 50일 SMA.  
* **RSI \< 50**: 상대강도지수가 중립 구간 하단 이하.  
* **MACD\_매수\_신호 \= True**: MACD \> Signal.  
* **추천\_여부 \= True**: 위 3가지 조건이 모두 참일 때 추천.

### **의미**

* 이 조합은 **추세(골든 크로스)**, **모멘텀(RSI)**, \*\*단기 상승력(MACD)\*\*을 종합적으로 고려하여 매수 추천을 결정합니다.  
* **강점**: 세 지표가 모두 긍정적인 신호를 보낼 때만 추천하므로, 매수 신호의 신뢰도가 높아질 가능성이 큽니다.  
* **약점**: 모든 조건을 만족해야 하므로 추천 종목 수가 적어질 수 있으며, 지나치게 보수적인 기준이 될 수 있습니다.

### **RSI \< 50의 적절성**

* **관대함 여부**: RSI \< 50은 기존 RSI \< 70보다 엄격하지만, 여전히 중립 구간(30\~50)을 포함하므로 과매도 상태(RSI \< 30)에 비하면 관대합니다. 이는 상승 가능성이 있는 종목을 더 포괄적으로 포함하려는 의도로 보입니다.  
* **조정 가능성**:  
  * **RSI \< 40**: 과매도에 가까운 상태로 더 강한 반등 가능성을 노릴 수 있음.  
  * **RSI \< 30**: 전통적인 과매도 기준으로, 가장 강한 매수 신호를 제공하지만 종목 수가 크게 줄어들 수 있음.

---

### **지표별 종합 비교**

| 지표 | 조건 | 역할 | 강점 | 약점 |
| ----- | ----- | ----- | ----- | ----- |
| 골든 크로스 | 20일 SMA \> 50일 SMA | 장기 추세 확인 | 단순하고 강한 상승 신호 | 후행성, 거짓 돌파 가능 |
| RSI | RSI \< 50 | 모멘텀 확인 | 과매도/과매수 탐지 | 단기 변동에 민감 |
| MACD | MACD \> Signal | 단기 모멘텀 확인 | 추세와 모멘텀 결합 | 횡보 장세에서 혼란 |

# **매수 추천 종목 선정 기준**

### **1\. 매수 추천 종목 선정 기준**

제공된 데이터는 get\_combined\_recommendations\_with\_technical\_and\_sentiment 함수를 통해 필터링된 결과로, 다음과 같은 조건을 만족하는 종목들입니다:

* **감정 점수(sentiment\_score)가 0.15 이상**: 기술적 지표(golden\_cross, rsi \< 50, macd\_buy\_signal) 중 **1개 이상** 만족.  
* **감정 점수가 null**: 기술적 지표 중 **2개 이상** 만족.

이 조건을 통해 7개 종목(SBUX, ADBE, PYPL, CSCO, TXN, CMCSA, PEP)이 매수 추천으로 선정되었습니다. 이제 이 중에서 **가장 추천할 만한 종목을 순위별로 나열**하고, 현재 매수 여부를 판단하겠습니다.

---

### **2\. 순위 매기기 기준**

단순히 필터링된 결과를 나열하는 대신, 종목의 매수 매력을 평가하기 위해 다음과 같은 요소를 종합 점수로 계산하여 순위를 매기겠습니다:

* **예측 상승률(rise\_probability)**: 주가 상승 가능성(단위: %).  
* **감정 점수(sentiment\_score)**: 시장 분위기 반영(-1 \~ 1, null은 0으로 처리).  
* **기술적 지표 강도(tech\_conditions\_count)**: golden\_cross, rsi \< 50, macd\_buy\_signal 중 만족한 개수(0\~3). 참고로 golden\_cross는 추가 가산을 더함

### **종합 점수 공식**

종합 점수=0.3×rise\_probability+0.3×sentiment\_score+0.4×tech\_conditions\_count

* **가중치**: 상승률(0.3), 감정 점수(0.3), 기술적 지표(0.4)로 설정. 이는 상승률과 모델 신뢰도를 우선시하며, 감정과 기술적 신호를 보조적으로 고려합니다.  
* **감정 점수 처리**: null은 0(중립)으로 간주.

---

### **3\. 종합 점수 계산 및 순위**

제공된 데이터를 바탕으로 각 종목의 종합 점수를 계산한 결과는 다음과 같습니다:

| 종목 | rise\_probability | accuracy | sentiment\_score | tech\_conditions\_count | 종합 점수 |
| ----- | ----- | ----- | ----- | ----- | ----- |
| SBUX | 10.54 | 90.64 | 0.0 (null) | 2 (golden\_cross, rsi\<50) | 31.25 |
| ADBE | 7.92 | 87.32 | 0.4357 | 1 (rsi\<50) | 29.78 |
| PYPL | 6.41 | 92.18 | 0.2742 | 1 (macd\_buy\_signal) | 30.47 |
| CSCO | 6.01 | 95.74 | 0.2478 | 2 (golden\_cross, rsi\<50) | 31.54 |
| TXN | 5.69 | 92.29 | 0.0 (null) | 2 (golden\_cross, rsi\<50) | 28.31 |
| CMCSA | 4.95 | 93.31 | 0.0 (null) | 2 (golden\_cross, rsi\<50) | 28.23 |
| PEP | 4.56 | 97.19 | 0.1661 | 2 (golden\_cross, rsi\<50) | 31.02 |

### **순위**

1. **CSCO (시스코)**: 31.54  
2. **SBUX (스타벅스)**: 31.25  
3. **PEP (펩시코)**: 31.02  
4. **PYPL (페이팔)**: 30.47  
5. **ADBE (어도비)**: 29.78  
6. **TXN (텍사스 인스트루먼트)**: 28.31  
7. **CMCSA (컴캐스트)**: 28.23

---

### **4\. 감정 점수 레이블 확인**

감정 점수(sentiment\_score)는 \-1 \~ 1 사이의 값으로, 다음 기준에 따라 분류됩니다:

* **Bearish (매도적)**: ≤ \-0.35  
* **Somewhat Bearish (약간 매도적)**: \-0.35 \< x ≤ \-0.15  
* **Neutral (중립)**: \-0.15 \< x \< 0.15  
* **Somewhat Bullish (약간 매수적)**: 0.15 ≤ x \< 0.35  
* **Bullish (매수적)**: ≥ 0.35

각 종목의 감정 점수와 레이블:

* SBUX: null (중립으로 간주)  
* ADBE: 0.4357 (Bullish)  
* PYPL: 0.2742 (Somewhat Bullish)  
* CSCO: 0.2478 (Somewhat Bullish)  
* TXN: null (중립으로 간주)  
* CMCSA: null (중립으로 간주)  
* PEP: 0.1661 (Somewhat Bullish)

---

### **5\. 주식 투자 전문가 관점에서 매수 추천**

종합 점수 상위 3개 종목(CSCO, SBUX, PEP)을 중심으로 매수 여부를 분석하겠습니다:

### **CSCO (시스코) \- 1위 (31.54)**

* **예측 상승률**: 6.01% (60.5 → 64.13)  
* **모델 정확도**: 95.74% (높은 신뢰도)  
* **감정 점수**: 0.2478 (Somewhat Bullish, 약간 매수적)  
* **기술적 지표**: 2개 만족 (golden\_cross, rsi\<50)  
* **판단**: 높은 모델 정확도와 긍정적인 감정 점수, 기술적 지표 강도가 조화를 이룸. **매수 추천**.

### **SBUX (스타벅스) \- 2위 (31.25)**

* **예측 상승률**: 10.54% (98.11 → 108.45, 가장 높음)  
* **모델 정확도**: 90.64% (양호)  
* **감정 점수**: null (중립)  
* **기술적 지표**: 2개 만족 (golden\_cross, rsi\<50)  
* **판단**: 감정 점수가 없지만, 높은 상승률과 기술적 지표 강도로 매력적. **매수 추천**.

### **PEP (펩시코) \- 3위 (31.02)**

* **예측 상승률**: 4.56% (148.59 → 155.36)  
* **모델 정확도**: 97.19% (가장 높음)  
* **감정 점수**: 0.1661 (Somewhat Bullish, 약간 매수적)  
* **기술적 지표**: 2개 만족 (golden\_cross, rsi\<50)  
* **판단**: 안정적인 상승률, 최고 수준의 정확도, 긍정적 감정 점수. **매수 추천**.

### **기타 종목**

* **PYPL (4위)**: 상승률 6.41%, 감정 점수 0.2742 (Somewhat Bullish), 기술적 지표 1개. 매수 가능성이 있지만 상위 3개에 비해 우선순위 낮음.  
* **ADBE (5위)**: 감정 점수 0.4357 (Bullish)로 강세이나, 상승률(7.92%)과 기술적 지표(1개)가 상대적으로 약함.  
* **TXN, CMCSA (6위, 7위)**: 감정 점수 없음, 상승률 낮음. 매수 우선순위 낮음.

### **6\. 최종 추천**

* **매수 추천 종목**: **CSCO, SBUX, PEP**  
  * **CSCO**: 높은 정확도와 안정적인 신호.  
  * **SBUX**: 가장 높은 상승률로 성장 가능성 큼.  
  * **PEP**: 안정성과 신뢰도 우수.  
* **현재 매수 여부**: 상위 3개 종목은 모두 매수하기에 적합합니다. 특히 **CSCO**와 **SBUX**는 단기 수익을, **PEP**는 안정적인 투자를 원하는 경우 추천.  
* **순위 리스트**: 위 함수 수정으로 results가 종합 점수 기준 내림차순으로 정렬되어 반환.

# **매도 로직 구체화**

### **3.3. 매도 대상 평가 및 실행**

1. 보유 종목의 Rise Probability (%), Accuracy (%)  
2. **뉴스 감성 분석**: 평균 감정 점수 \< \-0.15 시 매도 고려.  
3. **가격 기반**: \+5% 예약 매도, \-5% 손절 예약.  
4. **기술적 지표 확인**: 데드 크로스, RSI \> 70, MACD \< Signal.  
5. 한국투자증권 API로 매도 주문 실행.  
* 매도 대상 선정  
  * **조건 1**: 가격이 \+5% (익절) 또는 \-5% (손절)에 도달. → 매도  
  * **조건 2**: 감성 점수 \< \-0.15 이고 기술적 지표 중 2개 이상 매도 신호. → 현재가 기준 매도  
  * **조건 3**: 기술적 지표 중 3개 이상 매도 신호. → 현재가 기준 매도  
1. 내가 보유한 종목 리스트 조회하면 아래와 같은 정보를 원장(증권사)으로부터 얻을 수 있음. (**GET [/balance/overseas](http://localhost:8000/docs#/%EC%9E%94%EA%B3%A0/read_balance_overseas_balance_overseas_get)** 해외주식 잔고 조회 API 호출 → balance\_service.py의 **get\_overseas\_balance**() 함수 호출)

   * **데이터 추출 항목**:  
   * ovrs\_pdno: 종목 티커 (예: "ADBE")  
   * pchs\_avg\_pric: 매수 평균가 (예: "394.0550")  
   * ovrs\_cblc\_qty: 보유 수량 (예: "1")  
   * now\_pric2: 현재가 (예: "387.260000")  
   * ovrs\_item\_name: 종목명 (예: "어도비") – 기술적 지표 및 예측 정보 조회 시 필요

{  
  "ctx\_area\_fk200": "",  
  "ctx\_area\_nk200": "                                                                                                    ",  
  "output1": \[  
    {  
      "cano": "50124930",  
      "acnt\_prdt\_cd": "01",  
      "prdt\_type\_cd": "100",  
      "ovrs\_pdno": "ADBE",  
      "ovrs\_item\_name": "어도비",  
      "frcr\_evlu\_pfls\_amt": "-6.795000",  
      "evlu\_pfls\_rt": "-1.72",  
      "pchs\_avg\_pric": "394.0550",  
      "ovrs\_cblc\_qty": "1",  
      "ord\_psbl\_qty": "1",  
      "frcr\_pchs\_amt1": "394.05500",  
      "ovrs\_stck\_evlu\_amt": "387.26000000",  
      "now\_pric2": "387.260000",  
      "tr\_crcy\_cd": "USD",  
      "ovrs\_excg\_cd": "NASD",  
      "loan\_type\_cd": "",  
      "loan\_dt": "",  
      "expd\_dt": ""  
    },  
    {  
      "cano": "50124930",  
      "acnt\_prdt\_cd": "01",  
      "prdt\_type\_cd": "100",  
      "ovrs\_pdno": "AMGN",  
      "ovrs\_item\_name": "암젠",  
      "frcr\_evlu\_pfls\_amt": "38.200000",  
      "evlu\_pfls\_rt": "0.61",  
      "pchs\_avg\_pric": "314.1300",  
      "ovrs\_cblc\_qty": "20",  
      "ord\_psbl\_qty": "20",  
      "frcr\_pchs\_amt1": "6282.60000",  
      "ovrs\_stck\_evlu\_amt": "6320.80000000",  
      "now\_pric2": "316.040000",  
      "tr\_crcy\_cd": "USD",  
      "ovrs\_excg\_cd": "NASD",  
      "loan\_type\_cd": "",  
      "loan\_dt": "",  
      "expd\_dt": ""  
    },  
    {  
      "cano": "50124930",  
      "acnt\_prdt\_cd": "01",  
      "prdt\_type\_cd": "100",  
      "ovrs\_pdno": "CMCSA",  
      "ovrs\_item\_name": "컴캐스트",  
      "frcr\_evlu\_pfls\_amt": "1.310000",  
      "evlu\_pfls\_rt": "3.70",  
      "pchs\_avg\_pric": "35.4400",  
      "ovrs\_cblc\_qty": "1",  
      "ord\_psbl\_qty": "1",  
      "frcr\_pchs\_amt1": "35.44000",  
      "ovrs\_stck\_evlu\_amt": "36.75000000",  
      "now\_pric2": "36.750000",  
      "tr\_crcy\_cd": "USD",  
      "ovrs\_excg\_cd": "NASD",  
      "loan\_type\_cd": "",  
      "loan\_dt": "",  
      "expd\_dt": ""  
    },  
    {  
      "cano": "50124930",  
      "acnt\_prdt\_cd": "01",  
      "prdt\_type\_cd": "100",  
      "ovrs\_pdno": "COST",  
      "ovrs\_item\_name": "코스트코 홀세일",  
      "frcr\_evlu\_pfls\_amt": "107.900000",  
      "evlu\_pfls\_rt": "0.60",  
      "pchs\_avg\_pric": "903.8650",  
      "ovrs\_cblc\_qty": "20",  
      "ord\_psbl\_qty": "20",  
      "frcr\_pchs\_amt1": "18077.30000",  
      "ovrs\_stck\_evlu\_amt": "18185.20000000",  
      "now\_pric2": "909.260000",  
      "tr\_crcy\_cd": "USD",  
      "ovrs\_excg\_cd": "NASD",  
      "loan\_type\_cd": "",  
      "loan\_dt": "",  
      "expd\_dt": ""  
    },  
    {  
      "cano": "50124930",  
      "acnt\_prdt\_cd": "01",  
      "prdt\_type\_cd": "100",  
      "ovrs\_pdno": "CSCO",  
      "ovrs\_item\_name": "시스코 시스템즈",  
      "frcr\_evlu\_pfls\_amt": "-0.110000",  
      "evlu\_pfls\_rt": "-0.18",  
      "pchs\_avg\_pric": "60.4100",  
      "ovrs\_cblc\_qty": "1",  
      "ord\_psbl\_qty": "1",  
      "frcr\_pchs\_amt1": "60.41000",  
      "ovrs\_stck\_evlu\_amt": "60.30000000",  
      "now\_pric2": "60.300000",  
      "tr\_crcy\_cd": "USD",  
      "ovrs\_excg\_cd": "NASD",  
      "loan\_type\_cd": "",  
      "loan\_dt": "",  
      "expd\_dt": ""  
    },  
    {  
      "cano": "50124930",  
      "acnt\_prdt\_cd": "01",  
      "prdt\_type\_cd": "100",  
      "ovrs\_pdno": "MDLZ",  
      "ovrs\_item\_name": "몬덜리즈 인터내셔널",  
      "frcr\_evlu\_pfls\_amt": "51.000000",  
      "evlu\_pfls\_rt": "0.80",  
      "pchs\_avg\_pric": "64.0000",  
      "ovrs\_cblc\_qty": "100",  
      "ord\_psbl\_qty": "100",  
      "frcr\_pchs\_amt1": "6400.00000",  
      "ovrs\_stck\_evlu\_amt": "6451.00000000",  
      "now\_pric2": "64.510000",  
      "tr\_crcy\_cd": "USD",  
      "ovrs\_excg\_cd": "NASD",  
      "loan\_type\_cd": "",  
      "loan\_dt": "",  
      "expd\_dt": ""  
    },  
    {  
      "cano": "50124930",  
      "acnt\_prdt\_cd": "01",  
      "prdt\_type\_cd": "100",  
      "ovrs\_pdno": "PYPL",  
      "ovrs\_item\_name": "페이팔 홀딩스",  
      "frcr\_evlu\_pfls\_amt": "1.529900",  
      "evlu\_pfls\_rt": "2.23",  
      "pchs\_avg\_pric": "68.6600",  
      "ovrs\_cblc\_qty": "1",  
      "ord\_psbl\_qty": "1",  
      "frcr\_pchs\_amt1": "68.66010",  
      "ovrs\_stck\_evlu\_amt": "70.19000000",  
      "now\_pric2": "70.190000",  
      "tr\_crcy\_cd": "USD",  
      "ovrs\_excg\_cd": "NASD",  
      "loan\_type\_cd": "",  
      "loan\_dt": "",  
      "expd\_dt": ""  
    },  
    {  
      "cano": "50124930",  
      "acnt\_prdt\_cd": "01",  
      "prdt\_type\_cd": "100",  
      "ovrs\_pdno": "SBUX",  
      "ovrs\_item\_name": "스타벅스",  
      "frcr\_evlu\_pfls\_amt": "-41.650000",  
      "evlu\_pfls\_rt": "-1.69",  
      "pchs\_avg\_pric": "98.7360",  
      "ovrs\_cblc\_qty": "25",  
      "ord\_psbl\_qty": "25",  
      "frcr\_pchs\_amt1": "2468.40000",  
      "ovrs\_stck\_evlu\_amt": "2426.75000000",  
      "now\_pric2": "97.070000",  
      "tr\_crcy\_cd": "USD",  
      "ovrs\_excg\_cd": "NASD",  
      "loan\_type\_cd": "",  
      "loan\_dt": "",  
      "expd\_dt": ""  
    },  
    {  
      "cano": "50124930",  
      "acnt\_prdt\_cd": "01",  
      "prdt\_type\_cd": "100",  
      "ovrs\_pdno": "TXN",  
      "ovrs\_item\_name": "텍사스 인스트루먼츠",  
      "frcr\_evlu\_pfls\_amt": "-28.530000",  
      "evlu\_pfls\_rt": "-0.75",  
      "pchs\_avg\_pric": "180.3580",  
      "ovrs\_cblc\_qty": "21",  
      "ord\_psbl\_qty": "21",  
      "frcr\_pchs\_amt1": "3787.53000",  
      "ovrs\_stck\_evlu\_amt": "3759.00000000",  
      "now\_pric2": "179.000000",  
      "tr\_crcy\_cd": "USD",  
      "ovrs\_excg\_cd": "NASD",  
      "loan\_type\_cd": "",  
      "loan\_dt": "",  
      "expd\_dt": ""  
    }  
  \],  
  "output2": {  
    "frcr\_pchs\_amt1": "54828557.32992",  
    "ovrs\_rlzt\_pfls\_amt": "0.00000",  
    "ovrs\_tot\_pfls": "-237054.48192",  
    "rlzt\_erng\_rt": "0.00000000",  
    "tot\_evlu\_pfls\_amt": "-237054.48192000",  
    "tot\_pftrt": "-0.43235586",  
    "frcr\_buy\_amt\_smtl1": "54828557.329920",  
    "ovrs\_rlzt\_pfls\_amt2": "0.00000",  
    "frcr\_buy\_amt\_smtl2": "54828557.329920"  
  },  
  "rt\_cd": "0",  
  "msg\_cd": "20310000",  
  "msg1": "모의투자 조회가 완료되었습니다.                                                 "  
}

2.   
3. 구매가 대비 현재 가격이 \-5% 이하인 경우 손절 매도, 구매가 대비 현재 가격이 \+5% 이상인 경우 익절 매도.

4. **뉴스 감성 분석 데이터 조회**

* **테이블**: ticker\_sentiment\_analysis  
* **컬럼**:  
  * ticker: 종목 티커  
  * average\_sentiment\_score: 평균 감성 점수  
  * calculation\_date: 계산 날짜  
* **특이사항**: 보유 종목이라도 뉴스가 없으면 데이터가 없을 수 있음.  
* **구현 방법**:  
  * Supabase 클라이언트를 사용해 ticker\_sentiment\_analysis 테이블에서 각 종목의 감성 점수를 조회합니다.  
  * 데이터가 없으면 None을 반환하여 후속 조건에서 처리합니다.  
* **조건 적용**: 감성 분석이 부정적인 경우는 average\_sentiment\_score \< 0 로 정의합니다.  
1. **기술적 지표 데이터 조회**  
* **테이블**: stock\_recommendations  
* **컬럼**:  
  * 종목: 종목명 (예: "어도비")  
  * 날짜: 분석 날짜  
  * 골든\_크로스: 골든 크로스 여부 (True/False)  
  * RSI: RSI 지수  
  * MACD\_매수\_신호: MACD 매수 신호 여부 (True/False)  
* **구현 방법**:  
  * 보유 종목의 stock\_name을 사용해 기술적 지표를 조회합니다.  
* **매도 신호 정의**:  
  * 골든\_크로스 \== False (데드 크로스)  
  * RSI \> 70 (과매수 신호로 간주, 필요 시 조정 가능)  
  * MACD\_매수\_신호 \== False  
1. **추가 고려 사항**  
* 위 3번 (뉴스 감성 점수), 4번 (기술적 지표 분석) 항목에 대해서는 매도 로직 병합  
  * **조건 2**: 감성 점수 \< \-0.15 이고 기술적 지표 중 2개 이상 매도 신호. → 현재가 기준 매도  
  * **조건 3**: 기술적 지표 중 3개 이상 매도 신호. → 현재가 기준 매도  
* **데이터 매핑**: ticker와 stock\_name은 보유 종목 데이터에서 바로 연결되므로 별도 매핑이 필요 없을 수 있습니다. 하지만 테이블 간 불일치가 발생하면 매핑 딕셔너리(TICKER\_TO\_STOCK)를 사용하세요.

# **AI 주가 예측**

\# Supabase 클라이언트 설정  
\!pip install supabase  
from supabase import create\_client, Client  
import pandas as pd  
import numpy as np  
from sklearn.preprocessing import MinMaxScaler  
from tensorflow.keras.models import Model  
from tensorflow.keras.layers import (  
    Input, Dense, Dropout, LayerNormalization, MultiHeadAttention, Add, GlobalAveragePooling1D  
)  
import tensorflow as tf  
from tensorflow.keras.optimizers import Adam  
import matplotlib.pyplot as plt  
import matplotlib.dates as mdates

import json  
from sklearn.metrics import mean\_absolute\_error, mean\_squared\_error

\# Supabase 연결 설정  
url: str \= "여러분의 supabase 접근 url 입력해주세요."  
key: str \= "여러분의 supabase 접근 key 입력해주세요."  
supabase: Client \= create\_client(url, key)

\# Supabase에서 데이터 가져오기  
\# def get\_stock\_data\_from\_db():  
\#     try:  
\#         response \= supabase.table("economic\_and\_stock\_data").select("\*").order("날짜", desc=False).execute()  
\#         print(f"economic\_and\_stock\_data 테이블에서 {len(response.data)}개 데이터를 성공적으로 가져왔습니다\!")  
\#         print(response.data)  
\#         \# 응답 데이터를 DataFrame으로 변환  
\#         df \= pd.DataFrame(response.data)  
          
\#         \# 날짜 열을 datetime으로 변환  
\#         df\['날짜'\] \= pd.to\_datetime(df\['날짜'\])  
\#         df.sort\_values(by='날짜', inplace=True)  
          
\#         print("Handling missing values and filtering invalid data...")  
\#         df.fillna(method='ffill', inplace=True)  
\#         df.fillna(method='bfill', inplace=True)  
\#         df \= df.apply(pd.to\_numeric, errors='coerce')  
\#         df.dropna(inplace=True)  
          
\#         return df  
\#     except Exception as e:  
\#         print(f"데이터 가져오기 오류: {e}")  
\#         return None

def get\_stock\_data\_from\_db():  
    try:  
        \# 전체 데이터 가져오기  
        all\_data \= get\_all\_data("economic\_and\_stock\_data")  
        print(f"economic\_and\_stock\_data 테이블에서 {len(all\_data)}개 데이터를 성공적으로 가져왔습니다\!")  
        df \= pd.DataFrame(all\_data)

        \# 날짜 열을 datetime으로 변환하고 정렬  
        df\['날짜'\] \= pd.to\_datetime(df\['날짜'\])  
        df.sort\_values(by='날짜', inplace=True)

        \# 결측치 처리  
        print("결측치 처리 중...")  
        df \= df.ffill().bfill()  \# 앞/뒤 값으로 결측치 채우기

        \# 수치형 컬럼으로 변환  
        exclude\_columns \= \['날짜'\]  
        numeric\_columns \= \[col for col in df.columns if col not in exclude\_columns\]  
        df\[numeric\_columns\] \= df\[numeric\_columns\].apply(pd.to\_numeric, errors='coerce')

        \# NaN 비율 확인  
        nan\_ratios \= df\[numeric\_columns\].isna().mean()  
        print("수치형 컬럼별 NaN 비율:")  
        print(nan\_ratios)

        \# 유효한 데이터가 있는 컬럼만 dropna 대상으로 설정  
        valid\_columns \= \[col for col in numeric\_columns if nan\_ratios\[col\] \< 1.0\]  
        df.dropna(subset=valid\_columns, inplace=True)

        print(f"처리 후 데이터 크기: {df.shape}")  
        return df  
    except Exception as e:  
        print(f"데이터 가져오기 오류: {e}")  
        return None

def get\_all\_data(table\_name):  
    all\_data \= \[\]  
    offset \= 0  
    limit \= 1000  \# Supabase의 기본 제한  
    while True:  
        response \= supabase.table(table\_name).select("\*").order("날짜", desc=False).limit(limit).offset(offset).execute()  
        data \= response.data  
        if not data:  \# 더 이상 데이터가 없으면 종료  
            break  
        all\_data.extend(data)  
        offset \+= limit  
    return all\_data        

\# Transformer Encoder 정의  
def transformer\_encoder(inputs, num\_heads, ff\_dim, dropout=0.1):  
    attention\_output \= MultiHeadAttention(num\_heads=num\_heads, key\_dim=inputs.shape\[-1\])(inputs, inputs)  
    attention\_output \= Dropout(dropout)(attention\_output)  
    attention\_output \= Add()(\[inputs, attention\_output\])  
    attention\_output \= LayerNormalization(epsilon=1e-6)(attention\_output)

    ffn \= Dense(ff\_dim, activation="relu")(attention\_output)  
    ffn \= Dense(inputs.shape\[-1\])(ffn)  
    ffn\_output \= Dropout(dropout)(ffn)  
    ffn\_output \= Add()(\[attention\_output, ffn\_output\])  
    ffn\_output \= LayerNormalization(epsilon=1e-6)(ffn\_output)

    return ffn\_output

\# Transformer 모델 정의  
def build\_transformer\_with\_two\_inputs(stock\_shape, econ\_shape, num\_heads, ff\_dim, target\_size):  
    stock\_inputs \= Input(shape=stock\_shape)  
    stock\_encoded \= stock\_inputs  
    for \_ in range(4):  \# 4개의 Transformer Layer  
        stock\_encoded \= transformer\_encoder(stock\_encoded, num\_heads=num\_heads, ff\_dim=ff\_dim)  
    stock\_encoded \= Dense(64, activation="relu")(stock\_encoded)

    econ\_inputs \= Input(shape=econ\_shape)  
    econ\_encoded \= econ\_inputs  
    for \_ in range(4):  \# 4개의 Transformer Layer  
        econ\_encoded \= transformer\_encoder(econ\_encoded, num\_heads=num\_heads, ff\_dim=ff\_dim)  
    econ\_encoded \= Dense(64, activation="relu")(econ\_encoded)

    merged \= Add()(\[stock\_encoded, econ\_encoded\])  
    merged \= Dense(128, activation="relu")(merged)  
    merged \= Dropout(0.2)(merged)  
    merged \= GlobalAveragePooling1D()(merged)  
    outputs \= Dense(target\_size)(merged)

    return Model(inputs=\[stock\_inputs, econ\_inputs\], outputs=outputs)

print("Loading data from database...")  
data \= get\_stock\_data\_from\_db()  
if data is None or data.empty:  
    raise ValueError("DB에서 데이터를 가져오지 못했습니다. 테이블과 컬럼명을 확인하세요.")

\# data.sort\_values(by='날짜', inplace=True)

\# print("Handling missing values and filtering invalid data...")  
\# data.fillna(method='ffill', inplace=True)  
\# data.fillna(method='bfill', inplace=True)  
\# data \= data.apply(pd.to\_numeric, errors='coerce')  
\# data.dropna(inplace=True)

forecast\_horizon \= 14  \# 예측 기간 (14일 후를 예측)

target\_columns \= \[  
    '애플', '마이크로소프트', '아마존', '구글 A', '구글 C', '메타',   
    '테슬라', '엔비디아', '코스트코', '넷플릭스', '페이팔', '인텔', '시스코', '컴캐스트',   
    '펩시코', '암젠', '허니웰 인터내셔널', '스타벅스', '몬델리즈', '마이크론', '브로드컴',   
    '어도비', '텍사스 인스트루먼트', 'AMD', '어플라이드 머티리얼즈', 'S\&P 500 ETF', 'QQQ ETF'  
\]

economic\_features \= \[  
    '10년 기대 인플레이션율', '장단기 금리차', '기준금리', '미시간대 소비자 심리지수',   
    '실업률', '2년 만기 미국 국채 수익률', '10년 만기 미국 국채 수익률', '금융스트레스지수',   
    '개인 소비 지출', '소비자 물가지수', '5년 변동금리 모기지', '미국 달러 환율',   
    '통화 공급량 M2', '가계 부채 비율', 'GDP 성장률', '나스닥 종합지수', 'S\&P 500 지수', '금 가격', '달러 인덱스', '나스닥 100',   
    'S\&P 500 ETF', 'QQQ ETF', '러셀 2000 ETF', '다우 존스 ETF', 'VIX 지수',   
    '닛케이 225', '상해종합', '항셍', '영국 FTSE', '독일 DAX', '프랑스 CAC 40',   
    '미국 전체 채권시장 ETF', 'TIPS ETF', '투자등급 회사채 ETF', '달러/엔', '달러/위안',  
    '미국 리츠 ETF'  
\]

print("Scaling data...")  
train\_size \= int(len(data) \* 0.8)  
train\_data \= data.iloc\[:train\_size\]  
test\_data \= data.iloc\[train\_size:\]

data\_scaled \= data.copy()  
stock\_scaler \= MinMaxScaler()  
econ\_scaler \= MinMaxScaler()

data\_scaled\[target\_columns\] \= stock\_scaler.fit\_transform(data\[target\_columns\])  
data\_scaled\[economic\_features\] \= econ\_scaler.fit\_transform(data\[economic\_features\])

lookback \= 90

\# 훈련 데이터 생성  
X\_stock\_train \= \[\]  
X\_econ\_train \= \[\]  
y\_train \= \[\]

for i in range(lookback, len(data\_scaled) \- forecast\_horizon):  
    X\_stock\_seq \= data\_scaled\[target\_columns\].iloc\[i \- lookback:i\].to\_numpy()  
    X\_econ\_seq \= data\_scaled\[economic\_features\].iloc\[i \- lookback:i\].to\_numpy()  
    y\_val \= data\_scaled\[target\_columns\].iloc\[i \+ forecast\_horizon \- 1\].to\_numpy()  
    X\_stock\_train.append(X\_stock\_seq)  
    X\_econ\_train.append(X\_econ\_seq)  
    y\_train.append(y\_val)

X\_stock\_train \= np.array(X\_stock\_train)  
X\_econ\_train \= np.array(X\_econ\_train)  
y\_train \= np.array(y\_train)

\# 전체 예측 데이터 생성: 마지막 날짜까지 포함하여 예측 (미래 실제값 없어도 예측)  
X\_stock\_full \= \[\]  
X\_econ\_full \= \[\]  
for i in range(lookback, len(data\_scaled)):  \# 여기서 forecast\_horizon 빼지 않음  
    X\_stock\_seq \= data\_scaled\[target\_columns\].iloc\[i \- lookback:i\].to\_numpy()  
    X\_econ\_seq \= data\_scaled\[economic\_features\].iloc\[i \- lookback:i\].to\_numpy()  
    X\_stock\_full.append(X\_stock\_seq)  
    X\_econ\_full.append(X\_econ\_seq)

X\_stock\_full \= np.array(X\_stock\_full)  
X\_econ\_full \= np.array(X\_econ\_full)

print("Building Transformer model...")  
stock\_shape \= (lookback, len(target\_columns))  
econ\_shape \= (lookback, len(economic\_features))

model \= build\_transformer\_with\_two\_inputs(stock\_shape, econ\_shape, num\_heads=8, ff\_dim=256, target\_size=len(target\_columns))  
model.compile(optimizer=Adam(learning\_rate=0.0001), loss='mse', metrics=\['mae'\])  
model.summary()

print("Training model...")  
history \= model.fit(\[X\_stock\_train, X\_econ\_train\], y\_train, epochs=50, batch\_size=32, verbose=1)

print("Performing full predictions...")  
predicted\_prices \= model.predict(\[X\_stock\_full, X\_econ\_full\], verbose=1)  
predicted\_prices\_actual \= stock\_scaler.inverse\_transform(predicted\_prices)

pred\_len \= len(predicted\_prices\_actual)

\# 오늘 날짜들 (마지막 날짜까지 포함)  
today\_dates \= data\['날짜'\].iloc\[lookback : lookback \+ pred\_len\].values

\# 오늘 실제 주가 (오늘 날짜에 해당하는 실제값), 데이터 범위 넘어가면 NaN 처리  
actual\_data\_end \= min(lookback \+ pred\_len, len(data))  
actual\_full \= data\[target\_columns\].iloc\[lookback:actual\_data\_end\].values

\# 만약 actual\_full 길이가 pred\_len보다 짧다면 부족한 부분을 NaN으로 채움  
if actual\_full.shape\[0\] \< pred\_len:  
    nan\_padding \= np.full((pred\_len \- actual\_full.shape\[0\], len(target\_columns)), np.nan)  
    actual\_full \= np.vstack(\[actual\_full, nan\_padding\])

result\_data \= pd.DataFrame({'날짜': today\_dates})

for idx, col in enumerate(target\_columns):  
    result\_data\[f'{col}\_Predicted'\] \= predicted\_prices\_actual\[:, idx\]  
    result\_data\[f'{col}\_Actual'\] \= actual\_full\[:, idx\]

result\_data\['날짜'\] \= pd.to\_datetime(result\_data\['날짜'\], errors='coerce')  
result\_data\['날짜'\] \= result\_data\['날짜'\].dt.strftime('%Y-%m-%d')

\# \# 결과를 Supabase에 저장  
def save\_predictions\_to\_db(result\_df):  
    try:  
        \# 기존 테이블이 없으면 생성 (predicted\_stocks 테이블에 저장)  
        records \= result\_df.to\_dict('records')  
          
        \# 테이블에 먼저 데이터 삭제 후 새로 삽입  
        supabase.table("predicted\_stocks").delete().neq("id", 0).execute()  
          
        \# 일괄 삽입 (큰 데이터라면 청크로 나누어 삽입)  
        chunk\_size \= 100  
        for i in range(0, len(records), chunk\_size):  
            chunk \= records\[i:i+chunk\_size\]  
            response \= supabase.table("predicted\_stocks").insert(chunk).execute()  
          
        print(f"{len(records)}개의 예측 결과가 데이터베이스에 저장되었습니다.")  
    except Exception as e:  
        print(f"데이터베이스 저장 오류: {e}")

\# 예측 결과 저장  
save\_predictions\_to\_db(result\_data)

plt.figure(figsize=(12, 6))  
plt.plot(history.history\['loss'\], label='Train Loss')  
plt.title('Training Loss')  
plt.xlabel('Epoch')  
plt.ylabel('Loss')  
plt.legend()  
plt.show()

for col in target\_columns:  
    plt.figure(figsize=(12, 6))  
    plt.plot(pd.to\_datetime(result\_data\['날짜'\]), result\_data\[f'{col}\_Actual'\], label='Actual (Today)', alpha=0.7)  
    plt.plot(pd.to\_datetime(result\_data\['날짜'\]), result\_data\[f'{col}\_Predicted'\], label=f'Predicted ({forecast\_horizon} days later)', alpha=0.7)  
    plt.title(f'{col} \- Actual(Today) vs Predicted({forecast\_horizon} days later)')  
    plt.xlabel('Date (Today)')  
    plt.ylabel('Price')  
    plt.legend()  
    plt.xticks(rotation=45)  
    plt.grid()  
    plt.gca().xaxis.set\_major\_formatter(mdates.DateFormatter('%Y-%m-%d'))  
    plt.gcf().autofmt\_xdate()  
    plt.close()

print(f"모든 예측 결과가 DB에 저장되었습니다.")

\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\# 결과 추론 \#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#   
\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\# 결과 추론 \#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#   
\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\# 결과 추론 \#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\# 

\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#  
\# (0) Get Predictions From DB Function  
\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#

\# Supabase에서 예측 데이터 가져오기 (청크 단위)  
def get\_predictions\_from\_db(chunk\_size=1000):  
    try:  
        \# 전체 레코드 수 확인  
        count\_response \= supabase.table("predicted\_stocks").select("id", count="exact").execute()  
        total\_count \= count\_response.count  
        print(f"predicted\_stocks 테이블의 총 레코드 수: {total\_count}")

        \# 데이터를 저장할 빈 리스트  
        all\_data \= \[\]

        \# 청크 단위로 데이터 가져오기  
        for offset in range(0, total\_count, chunk\_size):  
            response \= (  
                supabase.table("predicted\_stocks")  
                .select("\*")  
                .order("날짜", desc=False)  
                .limit(chunk\_size)  
                .offset(offset)  
                .execute()  
            )  
            chunk\_data \= response.data  
            print(f"오프셋 {offset}에서 {len(chunk\_data)}개 데이터를 가져왔습니다.")  
            all\_data.extend(chunk\_data)

        \# 모든 데이터를 DataFrame으로 변환  
        df \= pd.DataFrame(all\_data)  
        print(f"총 {len(df)}개 데이터를 성공적으로 가져왔습니다\!")

        \# 날짜 열을 datetime으로 변환  
        df\['날짜'\] \= pd.to\_datetime(df\['날짜'\])

        return df  
    except Exception as e:  
        print(f"데이터 가져오기 오류: {e}")  
        return None

\# 결과를 Supabase에 저장  
def save\_analysis\_to\_db(result\_df):  
    try:  
        \# stock\_analysis\_results 테이블에 저장  
        records \= result\_df.to\_dict('records')  
          
        \# 테이블에 먼저 데이터 삭제 후 새로 삽입  
        supabase.table("stock\_analysis\_results").delete().neq("id", 0).execute()  
          
        \# 일괄 삽입 (큰 데이터라면 청크로 나누어 삽입)  
        chunk\_size \= 100  
        for i in range(0, len(records), chunk\_size):  
            chunk \= records\[i:i+chunk\_size\]  
            response \= supabase.table("stock\_analysis\_results").insert(chunk).execute()  
          
        print(f"{len(records)}개의 분석 결과가 데이터베이스에 저장되었습니다.")  
    except Exception as e:  
        print(f"데이터베이스 저장 오류: {e}")

\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#  
\# (1) Evaluation Function  
\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#  
def evaluate\_predictions(data, target\_columns, forecast\_horizon):  
    """  
    This function compares actual vs. predicted values (for the next 7 days)  
    and computes various metrics such as MAE, MSE, RMSE, MAPE, and Accuracy.

    \- MAE (Mean Absolute Error): Average absolute error between actual and predicted  
      (lower is better, same unit as original data)  
    \- MSE (Mean Squared Error): Average of squared errors  
      (lower is better)  
    \- RMSE (Root Mean Squared Error): Square root of MSE  
      (lower is better, often used with MAE)  
    \- MAPE (Mean Absolute Percentage Error): Error as a percentage of the actual values  
      (lower is better)  
    \- Accuracy (%): Computed as 100 \- MAPE, serving as a simple accuracy measure  
    """

    metrics \= \[\]

    for col in target\_columns:  
        \# 원래 컬럼명 그대로 사용  
        predicted\_col \= f'{col}\_Predicted'  
        actual\_col \= f'{col}\_Actual'

        \# Check if the columns exist  
        if predicted\_col not in data.columns or actual\_col not in data.columns:  
            print(f"Skipping {col}: Columns not found in data ({predicted\_col}, {actual\_col})")  
            continue

        \# Retrieve predicted and actual values  
        predicted \= data\[predicted\_col\]  
        \# Shift the actual values by forecast\_horizon days  
        \# so that today's prediction aligns with actual values 14 days ahead  
        actual \= data\[actual\_col\].shift(-forecast\_horizon)

        \# Use only valid (non-NaN) indices  
        valid\_idx \= \~predicted.isna() & \~actual.isna()  
        predicted \= predicted\[valid\_idx\]  
        actual \= actual\[valid\_idx\]

        if len(predicted) \== 0:  
            print(f"Skipping {col}: No valid prediction/actual pairs.")  
            continue

        \# Calculate metrics  
        mae \= mean\_absolute\_error(actual, predicted)  
        mse \= mean\_squared\_error(actual, predicted)  
        rmse \= mse \*\* 0.5  
        mape \= (abs((actual \- predicted) / actual).mean()) \* 100  
        accuracy \= 100 \- mape

        metrics.append({  
            'Stock': col,  
            'MAE': mae,  
            'MSE': mse,  
            'RMSE': rmse,  
            'MAPE (%)': mape,  
            'Accuracy (%)': accuracy  
        })

    return pd.DataFrame(metrics)

\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#  
\# (2) Future Rise Analysis  
\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#  
def analyze\_rise\_predictions(data, target\_columns):  
    """  
    This function looks at the last row of the DataFrame (most recent date),  
    compares actual vs. predicted values, and calculates rise/fall information  
    and rise probability in percentage.  
    """

    last\_row \= data.iloc\[-1\]  
    results \= \[\]

    for col in target\_columns:  
        \# 원래 컬럼명 그대로 사용  
        actual\_col \= f'{col}\_Actual'  
        predicted\_col \= f'{col}\_Predicted'  
          
        last\_actual\_price \= last\_row.get(actual\_col, np.nan)  
        predicted\_future\_price \= last\_row.get(predicted\_col, np.nan)

        \# Determine rise/fall and rise percentage  
        if pd.notna(last\_actual\_price) and pd.notna(predicted\_future\_price):  
            predicted\_rise \= predicted\_future\_price \> last\_actual\_price  
            rise\_probability \= ((predicted\_future\_price \- last\_actual\_price) / last\_actual\_price) \* 100  
        else:  
            predicted\_rise \= np.nan  
            rise\_probability \= np.nan

        results.append({  
            'Stock': col,  
            'Last Actual Price': last\_actual\_price,  
            'Predicted Future Price': predicted\_future\_price,  
            'Predicted Rise': predicted\_rise,  
            'Rise Probability (%)': rise\_probability  
        })

    return pd.DataFrame(results)

\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#  
\# (3) Buy/Sell Recommendation and Analysis  
\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#  
def generate\_recommendation(row):  
    """  
    Example logic:  
    \- (Predicted Rise \== True) and (Rise Probability \> 0\) \=\> BUY  
    \- (Rise Probability \> 2\) \=\> STRONG BUY  
    \- Otherwise \=\> SELL  
    """  
    rise\_prob \= row.get('Rise Probability (%)', 0\)  
    predicted\_rise \= row.get('Predicted Rise', False)

    if pd.isna(rise\_prob) or pd.isna(predicted\_rise):  
        return "No Data"

    if predicted\_rise and rise\_prob \> 0:  
        if rise\_prob \> 2:  
            return "STRONG BUY"  
        else:  
            return "BUY"  
    else:  
        return "SELL"

def generate\_analysis(row):  
    """  
    Provides a one-line comment for each entry.  
    Stock: stock name  
    Rise Probability (%): approximate rise probability  
    """  
    stock\_name \= row\['Stock'\]  
    rise\_prob \= row.get('Rise Probability (%)', 0\)  
    predicted\_rise \= row.get('Predicted Rise', False)

    if pd.isna(rise\_prob) or pd.isna(predicted\_rise):  
        return f"{stock\_name}: Not enough data"

    if predicted\_rise:  
        return f"{stock\_name} is expected to rise by about {rise\_prob:.2f}%. Consider buying or holding."  
    else:  
        return f"{stock\_name} is expected to fall by about {-rise\_prob:.2f}%. A cautious approach is recommended."

\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#  
\# (4) Main Code  
\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#  
\# 1\) Load Data from Supabase  
data \= get\_predictions\_from\_db(chunk\_size=1000)  
if data is None or len(data) \== 0:  
    print("데이터를 가져오는데 실패했습니다.")  
    exit(1)

\# 2\) Target columns  
target\_columns \= \[  
    '애플', '마이크로소프트', '아마존', '구글 A', '구글 C', '메타',   
    '테슬라', '엔비디아', '코스트코', '넷플릭스', '페이팔', '인텔', '시스코', '컴캐스트',   
    '펩시코', '암젠', '허니웰 인터내셔널', '스타벅스', '몬델리즈', '마이크론', '브로드컴',   
    '어도비', '텍사스 인스트루먼트', 'AMD', '어플라이드 머티리얼즈', 'S\&P 500 ETF', 'QQQ ETF'  
\]

forecast\_horizon \= 14  \# predicting 14 days ahead

\# 3\) Evaluate predictions  
evaluation\_results \= evaluate\_predictions(data, target\_columns, forecast\_horizon)  
print("============ Evaluation Results \============")  
print(evaluation\_results)

\# 4\) Analyze future rise  
rise\_results \= analyze\_rise\_predictions(data, target\_columns)  
print("============ Rise Predictions \============")  
print(rise\_results)

\# 5\) Merge DataFrames (evaluation metrics \+ rise analysis)  
final\_results \= pd.merge(evaluation\_results, rise\_results, on='Stock', how='outer')

\# 6\) Sort by rise probability (descending order)  
final\_results \= final\_results.sort\_values(by='Rise Probability (%)', ascending=False)

\# 7\) Generate buy/sell recommendations and analysis  
final\_results\['Recommendation'\] \= final\_results.apply(generate\_recommendation, axis=1)  
final\_results\['Analysis'\] \= final\_results.apply(generate\_analysis, axis=1)

\# Reorder columns  
column\_order \= \[  
    'Stock',  
    'MAE', 'MSE', 'RMSE', 'MAPE (%)', 'Accuracy (%)',  
    'Last Actual Price', 'Predicted Future Price', 'Predicted Rise', 'Rise Probability (%)',  
    'Recommendation', 'Analysis'  
\]  
final\_results \= final\_results\[column\_order\]

\# 8\) Save final results to Supabase  
save\_analysis\_to\_db(final\_results)  
print("\\\\n분석 결과가 'stock\_analysis\_results' 테이블에 저장되었습니다.")

\# 9\) Print final report  
print("=============== Final Report \===============")  
print(final\_results.to\_string(index=False))

# **MCP**

# **MCP(Model Context Protocol)란?**

MCP는 "Model Context Protocol"의 약자로, 인공지능 모델(특히 대규모 언어 모델, LLM)이 다양한 데이터 소스와 도구에 접근할 수 있도록 돕는 **표준화된 규칙**입니다. 이를 쉽게 이해하기 위해 USB-C 포트를 생각해보세요. USB-C 포트는 스마트폰, 노트북, 충전기 등 다양한 기기를 하나의 표준화된 방식으로 연결할 수 있게 해줍니다. 마찬가지로, MCP는 AI 모델이 파일, 데이터베이스, 인터넷 서비스 등 여러 데이터 소스와 도구에 연결할 수 있도록 **표준화된 연결 방식**을 제공합니다.

---

## **MCP가 왜 중요한가요?**

MCP는 AI를 더 유용하고 안전하게 활용할 수 있도록 돕습니다. 구체적으로 다음과 같은 장점을 제공합니다:

* **쉽게 연결 가능**: 개발자가 각 데이터 소스마다 별도의 코드를 작성할 필요 없이, MCP를 사용해 다양한 소스에 빠르게 연결할 수 있습니다.  
* **유연성**: 서로 다른 AI 제공업체(예: Claude, GPT 등)를 쉽게 바꿔가며 사용할 수 있습니다.  
* **보안**: 데이터 보안을 위한 모범 사례를 제공해 사용자의 정보가 안전하게 보호됩니다.

즉, MCP는 AI 모델이 더 똑똑하고 실용적인 작업을 할 수 있도록 연결과 보안을 간편하게 만들어줍니다.

---

## **MCP의 구조**

MCP는 **클라이언트-서버 구조**를 기반으로 작동합니다. 쉽게 말해, 사용자가 사용하는 프로그램과 데이터를 제공하는 서버가 MCP라는 규칙을 통해 소통합니다. 구조를 간단히 나누면 다음과 같습니다:

1. **호스트 애플리케이션**: 사용자가 직접 사용하는 프로그램입니다. 예를 들어, AI 도구(Claude Desktop)나 개발 환경(IDE)이 이에 해당합니다.  
2. **MCP 클라이언트**: 호스트 애플리케이션 안에 있는 부분으로, MCP 서버와 통신하며 데이터를 요청합니다.  
3. **MCP 서버**: 실제 데이터 소스(예: 컴퓨터의 파일, 인터넷 API 등)에 접근해 필요한 정보를 가져오는 역할을 합니다.

### **예시로 이해하기**

사용자가 AI 도구에서 "내 컴퓨터의 파일을 분석해줘"라고 요청한다고 가정해봅시다. 이 경우:

* **호스트 애플리케이션**(AI 도구)이 MCP 클라이언트에게 요청을 보냅니다.  
* **MCP 클라이언트**가 MCP 서버에 "파일 정보를 가져와"라고 전달합니다.  
* **MCP 서버**가 사용자의 컴퓨터에서 파일을 안전하게 가져와 AI 모델에 전달합니다.

이 과정을 통해 AI는 사용자의 데이터를 쉽게 분석할 수 있게 됩니다.

---

## **MCP의 장점 한눈에 보기**

| 특징 | 설명 |
| ----- | ----- |
| **표준화** | USB-C처럼 일관된 방식으로 AI와 데이터를 연결 |
| **효율성** | 개발자가 복잡한 코드를 작성하지 않아도 됨 |
| **안전성** | 데이터 보안을 위한 가이드 제공 |
| **확장성** | 로컬 파일부터 웹 API까지 다양한 소스와 연결 가능 |

---

## **MCP 시작하기**

MCP를 활용하려면 자신의 필요에 맞는 방법을 선택하면 됩니다:

* **개발자라면**:  
  * **서버 개발자**: MCP 서버를 만들어 AI 도구에서 데이터를 제공할 수 있습니다.  
  * **클라이언트 개발자**: MCP 클라이언트를 만들어 기존 서버와 통합할 수 있습니다.  
* **Claude Desktop 사용자라면**: 이미 만들어진 MCP 서버를 사용해 쉽게 시작할 수 있습니다.

더 자세한 정보는 [MCP 공식 문서](https://mcp-docs-url.com/)에서 확인할 수 있습니다(실제 링크는 문서에 따라 다름).

---

## **마무리**

MCP는 AI 모델이 다양한 데이터와 도구에 쉽게 접근할 수 있도록 하는 **표준화된 연결 다리**입니다. USB-C가 기기 연결을 단순화하듯, MCP는 AI와 데이터를 연결하는 과정을 단순화하고 안전하게 만들어줍니다.

# **한투 api 정의**

## **.env 환경변수 셋팅**

\# 한국투자증권 모의투자 API 설정  
\# KIS\_BASE\_URL=https://openapivts.koreainvestment.com:29443  
KIS\_REAL\_URL=https://openapi.koreainvestment.com:9443  
KIS\_APPKEY=  
KIS\_APPSECRET=  
KIS\_CANO=  
KIS\_ACNT\_PRDT\_CD=01  
KIS\_USE\_MOCK=false  
TR\_ID=

\# Supabase 설정 (코드에서 가져온 실제 값으로 수정)  
SUPABASE\_URL=  
SUPABASE\_KEY=

\# AlphaVantage API 키 (주식 추천 서비스에서 사용)  
ALPHA\_VANTAGE\_API\_KEY=

\# 기타 환경 설정  
DEBUG=true

## **해외주식 주문/계좌**

### **1\. 해외주식 주문**

* **API ID**: v1\_해외주식-001  
* **실전 TR\_ID**: (미국매수) TTTT1002U, (미국매도) TTTT1006U, (아시아) 규격서 참고  
* **모의 TR\_ID**: (미국매수) VTTT1002U, (미국매도) VTTT1001U, (아시아) 규격서 참고  
* **HTTP Method**: POST  
* **URL**: /uapi/overseas-stock/v1/trading/order  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: [https://openapivts.koreainvestment.com:29443](https://openapivts.koreainvestment.com:29443)

### **2\. 해외주식 정정취소주문**

* **API ID**: v1\_해외주식-003  
* **실전 TR\_ID HIST**: (미국) TTTT1004U, (아시아) 규격서 참고  
* **모의 TR\_ID**: (미국) VTTT1004U, (아시아) 규격서 참고  
* **HTTP Method**: POST  
* **URL**: /uapi/overseas-stock/v1/trading/order-rvsecncl  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: [https://openapivts.koreainvestment.com:29443](https://openapivts.koreainvestment.com:29443)

### **3\. 해외주식 예약주문접수**

* **API ID**: v1\_해외주식-002  
* **실전 TR\_ID**: (미국예약매수) TTTT3014U, (미국예약매도) TTTT3016U, (아시아) TTTS3013U  
* **모의 TR\_ID**: (미국예약매수) VTTT3014U, (미국예약매도) VTTT3016U, (아시아) VTTS3013U  
* **HTTP Method**: POST  
* **URL**: /uapi/overseas-stock/v1/trading/order-resv  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: [https://openapivts.koreainvestment.com:29443](https://openapivts.koreainvestment.com:29443)

### **4\. 해외주식 예약주문접수취소**

* **API ID**: v1\_해외주식-004  
* **실전 TR\_ID**: (미국) TTTT3017U, (아시아) 미제공  
* **모의 TR\_ID**: (미국) VTTT3017U, (아시아) 미제공  
* **HTTP Method**: POST  
* **URL**: /uapi/overseas-stock/v1/trading/order-resv-ccnl  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: [https://openapivts.koreainvestment.com:29443](https://openapivts.koreainvestment.com:29443)

### **5\. 해외주식 미체결내역**

* **API ID**: v1\_해외주식-005  
* **실전 TR\_ID**: TTTS3018R  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/trading/inquire-nccs  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 미지원

### **6\. 해외주식 잔고**

* **API ID**: v1\_해외주식-006  
* **실전 TR\_ID**: TTTS3012R  
* **모의 TR\_ID**: VTTS3012R  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/trading/inquire-balance  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: [https://openapivts.koreainvestment.com:29443](https://openapivts.koreainvestment.com:29443)

### **7\. 해외주식 주문체결내역**

* **API ID**: v1\_해외주식-007  
* **실전 TR\_ID**: TTTS3035R  
* **모의 TR\_ID**: VTTS3035R  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/trading/inquire-ccnl  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: [https://openapivts.koreainvestment.com:29443](https://openapivts.koreainvestment.com:29443)

### **8\. 해외주식 체결기준현재잔고**

* **API ID**: v1\_해외주식-008  
* **실전 TR\_ID**: CTRP6504R  
* **모의 TR\_ID**: VTRP6504R  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/trading/inquire-present-balance  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: [https://openapivts.koreainvestment.com:29443](https://openapivts.koreainvestment.com:29443) (output3만 이용 가능)

### **9\. 해외주식 예약주문조회**

* **API ID**: v1\_해외주식-013  
* **실전 TR\_ID**: (미국) TTTT3039R, (아시아) TTTS3014R  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/trading/order-resv-list  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 모의투자 미지원

### **10\. 해외주식 매수가능금액조회**

* **API ID**: v1\_해외주식-014  
* **실전 TR\_ID**: TTTS3007R  
* **모의 TR\_ID**: VTTS3007R  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/trading/inquire-psamount  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: [https://openapivts.koreainvestment.com:29443](https://openapivts.koreainvestment.com:29443)

### **11\. 해외주식 미국주간주문**

* **API ID**: v1\_해외주식-026  
* **실전 TR\_ID**: (주간매수) TTTS6036U, (주간매도) TTTS6037U  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: POST  
* **URL**: /uapi/overseas-stock/v1/trading/daytime-order  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 모의투자 미지원

### **12\. 해외주식 미국주간정정취소**

* **API ID**: v1\_해외주식-027  
* **실전 TR\_ID**: TTTS6038U  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: POST  
* **URL**: /uapi/overseas-stock/v1/trading/daytime-order-rvsecncl  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 모의투자 미지원

### **13\. 해외주식 기간손익**

* **API ID**: v1\_해외주식-032  
* **실전 TR\_ID**: TTTS3039R  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/trading/inquire-period-profit  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 모의투자 미지원

### **14\. 해외증거금 통화별조회**

* **API ID**: 해외주식-035  
* **실전 TR\_ID**: TTTC2101R  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/trading/foreign-margin  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 모의투자 미지원

### **15\. 해외주식 일별거래내역**

* **API ID**: 해외주식-063  
* **실전 TR\_ID**: CTOS4001R  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/trading/inquire-period-trans  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 모의투자 미지원

### **16\. 해외주식 결제기준잔고**

* **API ID**: 해외주식-064  
* **실전 TR\_ID**: CTRP6010R  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/trading/inquire-paymt-stdr-balance  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 모의투자 미지원

## **해외주식 기본시세**

### **1\. 해외주식 현재체결가**

* **API ID**: v1\_해외주식-009  
* **실전 TR\_ID**: HHDFS00000300  
* **모의 TR\_ID**: HHDFS00000300  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-price/v1/quotations/price  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: [https://openapivts.koreainvestment.com:29443](https://openapivts.koreainvestment.com:29443)

### **2\. 해외주식 기간별시세**

* **API ID**: v1\_해외주식-010  
* **실전 TR\_ID**: HHDFS76240000  
* **모의 TR\_ID**: HHDFS76240000  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-price/v1/quotations/dailyprice  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: [https://openapivts.koreainvestment.com:29443](https://openapivts.koreainvestment.com:29443)

### **3\. 해외주식 종목/지수/환율기간별시세(일/주/월/년)**

* **API ID**: v1\_해외주식-012  
* **실전 TR\_ID**: FHKST03030100  
* **모의 TR\_ID**: FHKST03030100  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-price/v1/quotations/inquire-daily-chartprice  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: [https://openapivts.koreainvestment.com:29443](https://openapivts.koreainvestment.com:29443)

### **4\. 해외주식조건검색**

* **API ID**: v1\_해외주식-015  
* **실전 TR\_ID**: HHDFS76410000  
* **모의 TR\_ID**: HHDFS76410000  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-price/v1/quotations/inquire-search  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: [https://openapivts.koreainvestment.com:29443](https://openapivts.koreainvestment.com:29443)

### **5\. 해외결제일자조회**

* **API ID**: 해외주식-017  
* **실전 TR\_ID**: CTOS5011R  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/quotations/countries-holiday  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 모의투자 미지원

### **6\. 해외주식 현재가상세**

* **API ID**: v1\_해외주식-029  
* **실전 TR\_ID**: HHDFS76200200  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-price/v1/quotations/price-detail  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 모의투자 미지원

### **7\. 해외주식분봉조회**

* **API ID**: v1\_해외주식-030  
* **실전 TR\_ID**: HHDFS76950200  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-price/v1/quotations/inquire-time-itemchartprice  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 모의투자 미지원

### **8\. 해외지수분봉조회**

* **API ID**: v1\_해외주식-031  
* **실전 TR\_ID**: FHKST03030200  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-price/v1/quotations/inquire-time-indexchartprice  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 모의투자 미지원

### **9\. 해외주식 상품기본정보**

* **API ID**: v1\_해외주식-034  
* **실전 TR\_ID**: CTPF1702R  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-price/v1/quotations/search-info  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 모의투자 미지원

### **10\. 해외주식 체결추이**

* **API ID**: 해외주식-037  
* **실전 TR\_ID**: HHDFS76200300  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-price/v1/quotations/inquire-ccnl  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 모의투자 미지원

### **11\. 해외주식 업종별시세**

* **API ID**: 해외주식-048  
* **실전 TR\_ID**: HHDFS76370000  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-price/v1/quotations/industry-theme  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 모의투자 미지원

### **12\. 해외주식 업종별코드조회**

* **API ID**: 해외주식-049  
* **실전 TR\_ID**: HHDFS76370100  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-price/v1/quotations/industry-price  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 모의투자 미지원

### **13\. 해외주식 현재가 1호가**

* **API ID**: 해외주식-033  
* **실전 TR\_ID**: HHDFS76200100  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-price/v1/quotations/inquire-asking-price  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 모의투자 미지원

## **해외주식 시세분석**

### **1\. 해외주식 가격급등락**

* **API ID**: 해외주식-038  
* **실전 TR\_ID**: HHDFS76260000  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/ranking/price-fluct  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 미지원

### **2\. 해외주식 거래량급증**

* **API ID**: 해외주식-039  
* **실전 TR\_ID**: HHDFS76270000  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/ranking/volume-surge  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 미지원

### **3\. 해외주식 매수체결강도상위**

* **API ID**: 해외주식-040  
* **실전 TR\_ID**: HHDFS76280000  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/ranking/volume-power  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 미지원

### **4\. 해외주식 상승율/하락율**

* **API ID**: 해외주식-041  
* **실전 TR\_ID**: HHDFS76290000  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/ranking/updown-rate  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 미지원

### **5\. 해외주식 신고/신저가**

* **API ID**: 해외주식-042  
* **실전 TR\_ID**: HHDFS76300000  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/ranking/new-highlow  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 미지원

### **6\. 해외주식 거래량순위**

* **API ID**: 해외주식-043  
* **실전 TR\_ID**: HHDFS76310010  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/ranking/trade-vol  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 미지원

### **7\. 해외주식 거래대금순위**

* **API ID**: 해외주식-044  
* **실전 TR\_ID**: HHDFS76320010  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/ranking/trade-pbmn  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 미지원

### **8\. 해외주식 거래증가율순위**

* **API ID**: 해외주식-045  
* **실전 TR\_ID**: HHDFS76330000  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/ranking/trade-growth  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 미지원

### **9\. 해외주식 거래회전율순위**

* **API ID**: 해외주식-046  
* **실전 TR\_ID**: HHDFS76340000  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/ranking/trade-turnover  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 미지원

### **10\. 해외주식 시가총액순위**

* **API ID**: 해외주식-047  
* **실전 TR\_ID**: HHDFS76350100  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-stock/v1/ranking/market-cap  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 미지원

### **11\. 해외주식 기간별권리조회**

* **API ID**: 해외주식-052  
* **실전 TR\_ID**: CTRGT011R  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-price/v1/quotations/period-rights  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 모의투자 미지원

### **12\. 해외뉴스종합(제목)**

* **API ID**: 해외주식-053  
* **실전 TR\_ID**: HHPSTH60100C1  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-price/v1/quotations/news-title  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 미지원

### **13\. 해외주식 권리종합**

* **API ID**: 해외주식-050  
* **실전 TR\_ID**: HHDFS78330900  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-price/v1/quotations/rights-by-ice  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 미지원

### **14\. 당사 해외주식담보대출 가능 종목**

* **API ID**: 해외주식-051  
* **실전 TR\_ID**: CTLN4050R  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-price/v1/quotations/colable-by-company  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 미지원

### **15\. 해외속보(제목)**

* **API ID**: 해외주식-055  
* **실전 TR\_ID**: FHKST01011801  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: GET  
* **URL**: /uapi/overseas-price/v1/quotations/brknews-title  
* **실전 Domain**: [https://openapi.koreainvestment.com:9443](https://openapi.koreainvestment.com:9443)  
* **모의 Domain**: 미지원

## **해외주식 실시간시세**

### **1\. 해외주식 실시간체결통보**

* **API ID**: 실시간-009  
* **실전 TR\_ID**: H0GSCNI0  
* **모의 TR\_ID**: H0GSCNI9  
* **HTTP Method**: POST  
* **URL**: /tryitout/H0GSCNI0  
* **실전 Domain**: ws://ops.koreainvestment.com:21000  
* **모의 Domain**: ws://ops.koreainvestment.com:31000

### **2\. 해외주식 실시간지연체결가**

* **API ID**: 실시간-007  
* **실전 TR\_ID**: HDFSCNT0  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: POST  
* **URL**: /tryitout/HDFSCNT0  
* **실전 Domain**: ws://ops.koreainvestment.com:21000  
* **모의 Domain**: 모의투자 미지원

### **3\. 해외주식 실시간지연호가(아시아)**

* **API ID**: 실시간-008  
* **실전 TR\_ID**: HDFSASP1  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: POST  
* **URL**: /tryitout/HDFSASP1  
* **실전 Domain**: ws://ops.koreainvestment.com:21000  
* **모의 Domain**: 제공 안함

### **4\. 해외주식 실시간호가(미국)**

* **API ID**: 실시간-021  
* **실전 TR\_ID**: HDFSASP0  
* **모의 TR\_ID**: 모의투자 미지원  
* **HTTP Method**: POST  
* **URL**: /tryitout/HDFSASP0  
* **실전 Domain**: ws://ops.koreainvestment.com:21000  
* **모의 Domain**: 모의투자 미지원

 